// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/mikestefanello/pagoda/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/mikestefanello/pagoda/ent/emailsubscription"
	"github.com/mikestefanello/pagoda/ent/emailsubscriptiontype"
	"github.com/mikestefanello/pagoda/ent/emojis"
	"github.com/mikestefanello/pagoda/ent/fcmsubscriptions"
	"github.com/mikestefanello/pagoda/ent/filestorage"
	"github.com/mikestefanello/pagoda/ent/image"
	"github.com/mikestefanello/pagoda/ent/imagesize"
	"github.com/mikestefanello/pagoda/ent/invitation"
	"github.com/mikestefanello/pagoda/ent/lastseenonline"
	"github.com/mikestefanello/pagoda/ent/monthlysubscription"
	"github.com/mikestefanello/pagoda/ent/notification"
	"github.com/mikestefanello/pagoda/ent/notificationpermission"
	"github.com/mikestefanello/pagoda/ent/notificationtime"
	"github.com/mikestefanello/pagoda/ent/passwordtoken"
	"github.com/mikestefanello/pagoda/ent/phoneverificationcode"
	"github.com/mikestefanello/pagoda/ent/profile"
	"github.com/mikestefanello/pagoda/ent/pwapushsubscription"
	"github.com/mikestefanello/pagoda/ent/sentemail"
	"github.com/mikestefanello/pagoda/ent/user"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// EmailSubscription is the client for interacting with the EmailSubscription builders.
	EmailSubscription *EmailSubscriptionClient
	// EmailSubscriptionType is the client for interacting with the EmailSubscriptionType builders.
	EmailSubscriptionType *EmailSubscriptionTypeClient
	// Emojis is the client for interacting with the Emojis builders.
	Emojis *EmojisClient
	// FCMSubscriptions is the client for interacting with the FCMSubscriptions builders.
	FCMSubscriptions *FCMSubscriptionsClient
	// FileStorage is the client for interacting with the FileStorage builders.
	FileStorage *FileStorageClient
	// Image is the client for interacting with the Image builders.
	Image *ImageClient
	// ImageSize is the client for interacting with the ImageSize builders.
	ImageSize *ImageSizeClient
	// Invitation is the client for interacting with the Invitation builders.
	Invitation *InvitationClient
	// LastSeenOnline is the client for interacting with the LastSeenOnline builders.
	LastSeenOnline *LastSeenOnlineClient
	// MonthlySubscription is the client for interacting with the MonthlySubscription builders.
	MonthlySubscription *MonthlySubscriptionClient
	// Notification is the client for interacting with the Notification builders.
	Notification *NotificationClient
	// NotificationPermission is the client for interacting with the NotificationPermission builders.
	NotificationPermission *NotificationPermissionClient
	// NotificationTime is the client for interacting with the NotificationTime builders.
	NotificationTime *NotificationTimeClient
	// PasswordToken is the client for interacting with the PasswordToken builders.
	PasswordToken *PasswordTokenClient
	// PhoneVerificationCode is the client for interacting with the PhoneVerificationCode builders.
	PhoneVerificationCode *PhoneVerificationCodeClient
	// Profile is the client for interacting with the Profile builders.
	Profile *ProfileClient
	// PwaPushSubscription is the client for interacting with the PwaPushSubscription builders.
	PwaPushSubscription *PwaPushSubscriptionClient
	// SentEmail is the client for interacting with the SentEmail builders.
	SentEmail *SentEmailClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.EmailSubscription = NewEmailSubscriptionClient(c.config)
	c.EmailSubscriptionType = NewEmailSubscriptionTypeClient(c.config)
	c.Emojis = NewEmojisClient(c.config)
	c.FCMSubscriptions = NewFCMSubscriptionsClient(c.config)
	c.FileStorage = NewFileStorageClient(c.config)
	c.Image = NewImageClient(c.config)
	c.ImageSize = NewImageSizeClient(c.config)
	c.Invitation = NewInvitationClient(c.config)
	c.LastSeenOnline = NewLastSeenOnlineClient(c.config)
	c.MonthlySubscription = NewMonthlySubscriptionClient(c.config)
	c.Notification = NewNotificationClient(c.config)
	c.NotificationPermission = NewNotificationPermissionClient(c.config)
	c.NotificationTime = NewNotificationTimeClient(c.config)
	c.PasswordToken = NewPasswordTokenClient(c.config)
	c.PhoneVerificationCode = NewPhoneVerificationCodeClient(c.config)
	c.Profile = NewProfileClient(c.config)
	c.PwaPushSubscription = NewPwaPushSubscriptionClient(c.config)
	c.SentEmail = NewSentEmailClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		EmailSubscription:      NewEmailSubscriptionClient(cfg),
		EmailSubscriptionType:  NewEmailSubscriptionTypeClient(cfg),
		Emojis:                 NewEmojisClient(cfg),
		FCMSubscriptions:       NewFCMSubscriptionsClient(cfg),
		FileStorage:            NewFileStorageClient(cfg),
		Image:                  NewImageClient(cfg),
		ImageSize:              NewImageSizeClient(cfg),
		Invitation:             NewInvitationClient(cfg),
		LastSeenOnline:         NewLastSeenOnlineClient(cfg),
		MonthlySubscription:    NewMonthlySubscriptionClient(cfg),
		Notification:           NewNotificationClient(cfg),
		NotificationPermission: NewNotificationPermissionClient(cfg),
		NotificationTime:       NewNotificationTimeClient(cfg),
		PasswordToken:          NewPasswordTokenClient(cfg),
		PhoneVerificationCode:  NewPhoneVerificationCodeClient(cfg),
		Profile:                NewProfileClient(cfg),
		PwaPushSubscription:    NewPwaPushSubscriptionClient(cfg),
		SentEmail:              NewSentEmailClient(cfg),
		User:                   NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		EmailSubscription:      NewEmailSubscriptionClient(cfg),
		EmailSubscriptionType:  NewEmailSubscriptionTypeClient(cfg),
		Emojis:                 NewEmojisClient(cfg),
		FCMSubscriptions:       NewFCMSubscriptionsClient(cfg),
		FileStorage:            NewFileStorageClient(cfg),
		Image:                  NewImageClient(cfg),
		ImageSize:              NewImageSizeClient(cfg),
		Invitation:             NewInvitationClient(cfg),
		LastSeenOnline:         NewLastSeenOnlineClient(cfg),
		MonthlySubscription:    NewMonthlySubscriptionClient(cfg),
		Notification:           NewNotificationClient(cfg),
		NotificationPermission: NewNotificationPermissionClient(cfg),
		NotificationTime:       NewNotificationTimeClient(cfg),
		PasswordToken:          NewPasswordTokenClient(cfg),
		PhoneVerificationCode:  NewPhoneVerificationCodeClient(cfg),
		Profile:                NewProfileClient(cfg),
		PwaPushSubscription:    NewPwaPushSubscriptionClient(cfg),
		SentEmail:              NewSentEmailClient(cfg),
		User:                   NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		EmailSubscription.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.EmailSubscription, c.EmailSubscriptionType, c.Emojis, c.FCMSubscriptions,
		c.FileStorage, c.Image, c.ImageSize, c.Invitation, c.LastSeenOnline,
		c.MonthlySubscription, c.Notification, c.NotificationPermission,
		c.NotificationTime, c.PasswordToken, c.PhoneVerificationCode, c.Profile,
		c.PwaPushSubscription, c.SentEmail, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.EmailSubscription, c.EmailSubscriptionType, c.Emojis, c.FCMSubscriptions,
		c.FileStorage, c.Image, c.ImageSize, c.Invitation, c.LastSeenOnline,
		c.MonthlySubscription, c.Notification, c.NotificationPermission,
		c.NotificationTime, c.PasswordToken, c.PhoneVerificationCode, c.Profile,
		c.PwaPushSubscription, c.SentEmail, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *EmailSubscriptionMutation:
		return c.EmailSubscription.mutate(ctx, m)
	case *EmailSubscriptionTypeMutation:
		return c.EmailSubscriptionType.mutate(ctx, m)
	case *EmojisMutation:
		return c.Emojis.mutate(ctx, m)
	case *FCMSubscriptionsMutation:
		return c.FCMSubscriptions.mutate(ctx, m)
	case *FileStorageMutation:
		return c.FileStorage.mutate(ctx, m)
	case *ImageMutation:
		return c.Image.mutate(ctx, m)
	case *ImageSizeMutation:
		return c.ImageSize.mutate(ctx, m)
	case *InvitationMutation:
		return c.Invitation.mutate(ctx, m)
	case *LastSeenOnlineMutation:
		return c.LastSeenOnline.mutate(ctx, m)
	case *MonthlySubscriptionMutation:
		return c.MonthlySubscription.mutate(ctx, m)
	case *NotificationMutation:
		return c.Notification.mutate(ctx, m)
	case *NotificationPermissionMutation:
		return c.NotificationPermission.mutate(ctx, m)
	case *NotificationTimeMutation:
		return c.NotificationTime.mutate(ctx, m)
	case *PasswordTokenMutation:
		return c.PasswordToken.mutate(ctx, m)
	case *PhoneVerificationCodeMutation:
		return c.PhoneVerificationCode.mutate(ctx, m)
	case *ProfileMutation:
		return c.Profile.mutate(ctx, m)
	case *PwaPushSubscriptionMutation:
		return c.PwaPushSubscription.mutate(ctx, m)
	case *SentEmailMutation:
		return c.SentEmail.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// EmailSubscriptionClient is a client for the EmailSubscription schema.
type EmailSubscriptionClient struct {
	config
}

// NewEmailSubscriptionClient returns a client for the EmailSubscription from the given config.
func NewEmailSubscriptionClient(c config) *EmailSubscriptionClient {
	return &EmailSubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emailsubscription.Hooks(f(g(h())))`.
func (c *EmailSubscriptionClient) Use(hooks ...Hook) {
	c.hooks.EmailSubscription = append(c.hooks.EmailSubscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `emailsubscription.Intercept(f(g(h())))`.
func (c *EmailSubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmailSubscription = append(c.inters.EmailSubscription, interceptors...)
}

// Create returns a builder for creating a EmailSubscription entity.
func (c *EmailSubscriptionClient) Create() *EmailSubscriptionCreate {
	mutation := newEmailSubscriptionMutation(c.config, OpCreate)
	return &EmailSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmailSubscription entities.
func (c *EmailSubscriptionClient) CreateBulk(builders ...*EmailSubscriptionCreate) *EmailSubscriptionCreateBulk {
	return &EmailSubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmailSubscriptionClient) MapCreateBulk(slice any, setFunc func(*EmailSubscriptionCreate, int)) *EmailSubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmailSubscriptionCreateBulk{err: fmt.Errorf("calling to EmailSubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmailSubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmailSubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmailSubscription.
func (c *EmailSubscriptionClient) Update() *EmailSubscriptionUpdate {
	mutation := newEmailSubscriptionMutation(c.config, OpUpdate)
	return &EmailSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailSubscriptionClient) UpdateOne(es *EmailSubscription) *EmailSubscriptionUpdateOne {
	mutation := newEmailSubscriptionMutation(c.config, OpUpdateOne, withEmailSubscription(es))
	return &EmailSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailSubscriptionClient) UpdateOneID(id int) *EmailSubscriptionUpdateOne {
	mutation := newEmailSubscriptionMutation(c.config, OpUpdateOne, withEmailSubscriptionID(id))
	return &EmailSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmailSubscription.
func (c *EmailSubscriptionClient) Delete() *EmailSubscriptionDelete {
	mutation := newEmailSubscriptionMutation(c.config, OpDelete)
	return &EmailSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmailSubscriptionClient) DeleteOne(es *EmailSubscription) *EmailSubscriptionDeleteOne {
	return c.DeleteOneID(es.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmailSubscriptionClient) DeleteOneID(id int) *EmailSubscriptionDeleteOne {
	builder := c.Delete().Where(emailsubscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailSubscriptionDeleteOne{builder}
}

// Query returns a query builder for EmailSubscription.
func (c *EmailSubscriptionClient) Query() *EmailSubscriptionQuery {
	return &EmailSubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmailSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a EmailSubscription entity by its id.
func (c *EmailSubscriptionClient) Get(ctx context.Context, id int) (*EmailSubscription, error) {
	return c.Query().Where(emailsubscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailSubscriptionClient) GetX(ctx context.Context, id int) *EmailSubscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubscriptions queries the subscriptions edge of a EmailSubscription.
func (c *EmailSubscriptionClient) QuerySubscriptions(es *EmailSubscription) *EmailSubscriptionTypeQuery {
	query := (&EmailSubscriptionTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := es.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsubscription.Table, emailsubscription.FieldID, id),
			sqlgraph.To(emailsubscriptiontype.Table, emailsubscriptiontype.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, emailsubscription.SubscriptionsTable, emailsubscription.SubscriptionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(es.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmailSubscriptionClient) Hooks() []Hook {
	return c.hooks.EmailSubscription
}

// Interceptors returns the client interceptors.
func (c *EmailSubscriptionClient) Interceptors() []Interceptor {
	return c.inters.EmailSubscription
}

func (c *EmailSubscriptionClient) mutate(ctx context.Context, m *EmailSubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmailSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmailSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmailSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmailSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EmailSubscription mutation op: %q", m.Op())
	}
}

// EmailSubscriptionTypeClient is a client for the EmailSubscriptionType schema.
type EmailSubscriptionTypeClient struct {
	config
}

// NewEmailSubscriptionTypeClient returns a client for the EmailSubscriptionType from the given config.
func NewEmailSubscriptionTypeClient(c config) *EmailSubscriptionTypeClient {
	return &EmailSubscriptionTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emailsubscriptiontype.Hooks(f(g(h())))`.
func (c *EmailSubscriptionTypeClient) Use(hooks ...Hook) {
	c.hooks.EmailSubscriptionType = append(c.hooks.EmailSubscriptionType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `emailsubscriptiontype.Intercept(f(g(h())))`.
func (c *EmailSubscriptionTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmailSubscriptionType = append(c.inters.EmailSubscriptionType, interceptors...)
}

// Create returns a builder for creating a EmailSubscriptionType entity.
func (c *EmailSubscriptionTypeClient) Create() *EmailSubscriptionTypeCreate {
	mutation := newEmailSubscriptionTypeMutation(c.config, OpCreate)
	return &EmailSubscriptionTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmailSubscriptionType entities.
func (c *EmailSubscriptionTypeClient) CreateBulk(builders ...*EmailSubscriptionTypeCreate) *EmailSubscriptionTypeCreateBulk {
	return &EmailSubscriptionTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmailSubscriptionTypeClient) MapCreateBulk(slice any, setFunc func(*EmailSubscriptionTypeCreate, int)) *EmailSubscriptionTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmailSubscriptionTypeCreateBulk{err: fmt.Errorf("calling to EmailSubscriptionTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmailSubscriptionTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmailSubscriptionTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmailSubscriptionType.
func (c *EmailSubscriptionTypeClient) Update() *EmailSubscriptionTypeUpdate {
	mutation := newEmailSubscriptionTypeMutation(c.config, OpUpdate)
	return &EmailSubscriptionTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailSubscriptionTypeClient) UpdateOne(est *EmailSubscriptionType) *EmailSubscriptionTypeUpdateOne {
	mutation := newEmailSubscriptionTypeMutation(c.config, OpUpdateOne, withEmailSubscriptionType(est))
	return &EmailSubscriptionTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailSubscriptionTypeClient) UpdateOneID(id int) *EmailSubscriptionTypeUpdateOne {
	mutation := newEmailSubscriptionTypeMutation(c.config, OpUpdateOne, withEmailSubscriptionTypeID(id))
	return &EmailSubscriptionTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmailSubscriptionType.
func (c *EmailSubscriptionTypeClient) Delete() *EmailSubscriptionTypeDelete {
	mutation := newEmailSubscriptionTypeMutation(c.config, OpDelete)
	return &EmailSubscriptionTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmailSubscriptionTypeClient) DeleteOne(est *EmailSubscriptionType) *EmailSubscriptionTypeDeleteOne {
	return c.DeleteOneID(est.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmailSubscriptionTypeClient) DeleteOneID(id int) *EmailSubscriptionTypeDeleteOne {
	builder := c.Delete().Where(emailsubscriptiontype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailSubscriptionTypeDeleteOne{builder}
}

// Query returns a query builder for EmailSubscriptionType.
func (c *EmailSubscriptionTypeClient) Query() *EmailSubscriptionTypeQuery {
	return &EmailSubscriptionTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmailSubscriptionType},
		inters: c.Interceptors(),
	}
}

// Get returns a EmailSubscriptionType entity by its id.
func (c *EmailSubscriptionTypeClient) Get(ctx context.Context, id int) (*EmailSubscriptionType, error) {
	return c.Query().Where(emailsubscriptiontype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailSubscriptionTypeClient) GetX(ctx context.Context, id int) *EmailSubscriptionType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubscriber queries the subscriber edge of a EmailSubscriptionType.
func (c *EmailSubscriptionTypeClient) QuerySubscriber(est *EmailSubscriptionType) *EmailSubscriptionQuery {
	query := (&EmailSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := est.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsubscriptiontype.Table, emailsubscriptiontype.FieldID, id),
			sqlgraph.To(emailsubscription.Table, emailsubscription.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, emailsubscriptiontype.SubscriberTable, emailsubscriptiontype.SubscriberPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(est.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmailSubscriptionTypeClient) Hooks() []Hook {
	return c.hooks.EmailSubscriptionType
}

// Interceptors returns the client interceptors.
func (c *EmailSubscriptionTypeClient) Interceptors() []Interceptor {
	return c.inters.EmailSubscriptionType
}

func (c *EmailSubscriptionTypeClient) mutate(ctx context.Context, m *EmailSubscriptionTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmailSubscriptionTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmailSubscriptionTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmailSubscriptionTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmailSubscriptionTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EmailSubscriptionType mutation op: %q", m.Op())
	}
}

// EmojisClient is a client for the Emojis schema.
type EmojisClient struct {
	config
}

// NewEmojisClient returns a client for the Emojis from the given config.
func NewEmojisClient(c config) *EmojisClient {
	return &EmojisClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emojis.Hooks(f(g(h())))`.
func (c *EmojisClient) Use(hooks ...Hook) {
	c.hooks.Emojis = append(c.hooks.Emojis, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `emojis.Intercept(f(g(h())))`.
func (c *EmojisClient) Intercept(interceptors ...Interceptor) {
	c.inters.Emojis = append(c.inters.Emojis, interceptors...)
}

// Create returns a builder for creating a Emojis entity.
func (c *EmojisClient) Create() *EmojisCreate {
	mutation := newEmojisMutation(c.config, OpCreate)
	return &EmojisCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Emojis entities.
func (c *EmojisClient) CreateBulk(builders ...*EmojisCreate) *EmojisCreateBulk {
	return &EmojisCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmojisClient) MapCreateBulk(slice any, setFunc func(*EmojisCreate, int)) *EmojisCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmojisCreateBulk{err: fmt.Errorf("calling to EmojisClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmojisCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmojisCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Emojis.
func (c *EmojisClient) Update() *EmojisUpdate {
	mutation := newEmojisMutation(c.config, OpUpdate)
	return &EmojisUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmojisClient) UpdateOne(e *Emojis) *EmojisUpdateOne {
	mutation := newEmojisMutation(c.config, OpUpdateOne, withEmojis(e))
	return &EmojisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmojisClient) UpdateOneID(id int) *EmojisUpdateOne {
	mutation := newEmojisMutation(c.config, OpUpdateOne, withEmojisID(id))
	return &EmojisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Emojis.
func (c *EmojisClient) Delete() *EmojisDelete {
	mutation := newEmojisMutation(c.config, OpDelete)
	return &EmojisDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmojisClient) DeleteOne(e *Emojis) *EmojisDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmojisClient) DeleteOneID(id int) *EmojisDeleteOne {
	builder := c.Delete().Where(emojis.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmojisDeleteOne{builder}
}

// Query returns a query builder for Emojis.
func (c *EmojisClient) Query() *EmojisQuery {
	return &EmojisQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmojis},
		inters: c.Interceptors(),
	}
}

// Get returns a Emojis entity by its id.
func (c *EmojisClient) Get(ctx context.Context, id int) (*Emojis, error) {
	return c.Query().Where(emojis.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmojisClient) GetX(ctx context.Context, id int) *Emojis {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EmojisClient) Hooks() []Hook {
	return c.hooks.Emojis
}

// Interceptors returns the client interceptors.
func (c *EmojisClient) Interceptors() []Interceptor {
	return c.inters.Emojis
}

func (c *EmojisClient) mutate(ctx context.Context, m *EmojisMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmojisCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmojisUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmojisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmojisDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Emojis mutation op: %q", m.Op())
	}
}

// FCMSubscriptionsClient is a client for the FCMSubscriptions schema.
type FCMSubscriptionsClient struct {
	config
}

// NewFCMSubscriptionsClient returns a client for the FCMSubscriptions from the given config.
func NewFCMSubscriptionsClient(c config) *FCMSubscriptionsClient {
	return &FCMSubscriptionsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fcmsubscriptions.Hooks(f(g(h())))`.
func (c *FCMSubscriptionsClient) Use(hooks ...Hook) {
	c.hooks.FCMSubscriptions = append(c.hooks.FCMSubscriptions, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fcmsubscriptions.Intercept(f(g(h())))`.
func (c *FCMSubscriptionsClient) Intercept(interceptors ...Interceptor) {
	c.inters.FCMSubscriptions = append(c.inters.FCMSubscriptions, interceptors...)
}

// Create returns a builder for creating a FCMSubscriptions entity.
func (c *FCMSubscriptionsClient) Create() *FCMSubscriptionsCreate {
	mutation := newFCMSubscriptionsMutation(c.config, OpCreate)
	return &FCMSubscriptionsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FCMSubscriptions entities.
func (c *FCMSubscriptionsClient) CreateBulk(builders ...*FCMSubscriptionsCreate) *FCMSubscriptionsCreateBulk {
	return &FCMSubscriptionsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FCMSubscriptionsClient) MapCreateBulk(slice any, setFunc func(*FCMSubscriptionsCreate, int)) *FCMSubscriptionsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FCMSubscriptionsCreateBulk{err: fmt.Errorf("calling to FCMSubscriptionsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FCMSubscriptionsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FCMSubscriptionsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FCMSubscriptions.
func (c *FCMSubscriptionsClient) Update() *FCMSubscriptionsUpdate {
	mutation := newFCMSubscriptionsMutation(c.config, OpUpdate)
	return &FCMSubscriptionsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FCMSubscriptionsClient) UpdateOne(fs *FCMSubscriptions) *FCMSubscriptionsUpdateOne {
	mutation := newFCMSubscriptionsMutation(c.config, OpUpdateOne, withFCMSubscriptions(fs))
	return &FCMSubscriptionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FCMSubscriptionsClient) UpdateOneID(id int) *FCMSubscriptionsUpdateOne {
	mutation := newFCMSubscriptionsMutation(c.config, OpUpdateOne, withFCMSubscriptionsID(id))
	return &FCMSubscriptionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FCMSubscriptions.
func (c *FCMSubscriptionsClient) Delete() *FCMSubscriptionsDelete {
	mutation := newFCMSubscriptionsMutation(c.config, OpDelete)
	return &FCMSubscriptionsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FCMSubscriptionsClient) DeleteOne(fs *FCMSubscriptions) *FCMSubscriptionsDeleteOne {
	return c.DeleteOneID(fs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FCMSubscriptionsClient) DeleteOneID(id int) *FCMSubscriptionsDeleteOne {
	builder := c.Delete().Where(fcmsubscriptions.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FCMSubscriptionsDeleteOne{builder}
}

// Query returns a query builder for FCMSubscriptions.
func (c *FCMSubscriptionsClient) Query() *FCMSubscriptionsQuery {
	return &FCMSubscriptionsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFCMSubscriptions},
		inters: c.Interceptors(),
	}
}

// Get returns a FCMSubscriptions entity by its id.
func (c *FCMSubscriptionsClient) Get(ctx context.Context, id int) (*FCMSubscriptions, error) {
	return c.Query().Where(fcmsubscriptions.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FCMSubscriptionsClient) GetX(ctx context.Context, id int) *FCMSubscriptions {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a FCMSubscriptions.
func (c *FCMSubscriptionsClient) QueryProfile(fs *FCMSubscriptions) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fcmsubscriptions.Table, fcmsubscriptions.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fcmsubscriptions.ProfileTable, fcmsubscriptions.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(fs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FCMSubscriptionsClient) Hooks() []Hook {
	return c.hooks.FCMSubscriptions
}

// Interceptors returns the client interceptors.
func (c *FCMSubscriptionsClient) Interceptors() []Interceptor {
	return c.inters.FCMSubscriptions
}

func (c *FCMSubscriptionsClient) mutate(ctx context.Context, m *FCMSubscriptionsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FCMSubscriptionsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FCMSubscriptionsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FCMSubscriptionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FCMSubscriptionsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FCMSubscriptions mutation op: %q", m.Op())
	}
}

// FileStorageClient is a client for the FileStorage schema.
type FileStorageClient struct {
	config
}

// NewFileStorageClient returns a client for the FileStorage from the given config.
func NewFileStorageClient(c config) *FileStorageClient {
	return &FileStorageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `filestorage.Hooks(f(g(h())))`.
func (c *FileStorageClient) Use(hooks ...Hook) {
	c.hooks.FileStorage = append(c.hooks.FileStorage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `filestorage.Intercept(f(g(h())))`.
func (c *FileStorageClient) Intercept(interceptors ...Interceptor) {
	c.inters.FileStorage = append(c.inters.FileStorage, interceptors...)
}

// Create returns a builder for creating a FileStorage entity.
func (c *FileStorageClient) Create() *FileStorageCreate {
	mutation := newFileStorageMutation(c.config, OpCreate)
	return &FileStorageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FileStorage entities.
func (c *FileStorageClient) CreateBulk(builders ...*FileStorageCreate) *FileStorageCreateBulk {
	return &FileStorageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileStorageClient) MapCreateBulk(slice any, setFunc func(*FileStorageCreate, int)) *FileStorageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileStorageCreateBulk{err: fmt.Errorf("calling to FileStorageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileStorageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileStorageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FileStorage.
func (c *FileStorageClient) Update() *FileStorageUpdate {
	mutation := newFileStorageMutation(c.config, OpUpdate)
	return &FileStorageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileStorageClient) UpdateOne(fs *FileStorage) *FileStorageUpdateOne {
	mutation := newFileStorageMutation(c.config, OpUpdateOne, withFileStorage(fs))
	return &FileStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileStorageClient) UpdateOneID(id int) *FileStorageUpdateOne {
	mutation := newFileStorageMutation(c.config, OpUpdateOne, withFileStorageID(id))
	return &FileStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FileStorage.
func (c *FileStorageClient) Delete() *FileStorageDelete {
	mutation := newFileStorageMutation(c.config, OpDelete)
	return &FileStorageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileStorageClient) DeleteOne(fs *FileStorage) *FileStorageDeleteOne {
	return c.DeleteOneID(fs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileStorageClient) DeleteOneID(id int) *FileStorageDeleteOne {
	builder := c.Delete().Where(filestorage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileStorageDeleteOne{builder}
}

// Query returns a query builder for FileStorage.
func (c *FileStorageClient) Query() *FileStorageQuery {
	return &FileStorageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFileStorage},
		inters: c.Interceptors(),
	}
}

// Get returns a FileStorage entity by its id.
func (c *FileStorageClient) Get(ctx context.Context, id int) (*FileStorage, error) {
	return c.Query().Where(filestorage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileStorageClient) GetX(ctx context.Context, id int) *FileStorage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FileStorageClient) Hooks() []Hook {
	return c.hooks.FileStorage
}

// Interceptors returns the client interceptors.
func (c *FileStorageClient) Interceptors() []Interceptor {
	return c.inters.FileStorage
}

func (c *FileStorageClient) mutate(ctx context.Context, m *FileStorageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileStorageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileStorageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileStorageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FileStorage mutation op: %q", m.Op())
	}
}

// ImageClient is a client for the Image schema.
type ImageClient struct {
	config
}

// NewImageClient returns a client for the Image from the given config.
func NewImageClient(c config) *ImageClient {
	return &ImageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `image.Hooks(f(g(h())))`.
func (c *ImageClient) Use(hooks ...Hook) {
	c.hooks.Image = append(c.hooks.Image, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `image.Intercept(f(g(h())))`.
func (c *ImageClient) Intercept(interceptors ...Interceptor) {
	c.inters.Image = append(c.inters.Image, interceptors...)
}

// Create returns a builder for creating a Image entity.
func (c *ImageClient) Create() *ImageCreate {
	mutation := newImageMutation(c.config, OpCreate)
	return &ImageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Image entities.
func (c *ImageClient) CreateBulk(builders ...*ImageCreate) *ImageCreateBulk {
	return &ImageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ImageClient) MapCreateBulk(slice any, setFunc func(*ImageCreate, int)) *ImageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ImageCreateBulk{err: fmt.Errorf("calling to ImageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ImageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ImageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Image.
func (c *ImageClient) Update() *ImageUpdate {
	mutation := newImageMutation(c.config, OpUpdate)
	return &ImageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ImageClient) UpdateOne(i *Image) *ImageUpdateOne {
	mutation := newImageMutation(c.config, OpUpdateOne, withImage(i))
	return &ImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ImageClient) UpdateOneID(id int) *ImageUpdateOne {
	mutation := newImageMutation(c.config, OpUpdateOne, withImageID(id))
	return &ImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Image.
func (c *ImageClient) Delete() *ImageDelete {
	mutation := newImageMutation(c.config, OpDelete)
	return &ImageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ImageClient) DeleteOne(i *Image) *ImageDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ImageClient) DeleteOneID(id int) *ImageDeleteOne {
	builder := c.Delete().Where(image.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ImageDeleteOne{builder}
}

// Query returns a query builder for Image.
func (c *ImageClient) Query() *ImageQuery {
	return &ImageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeImage},
		inters: c.Interceptors(),
	}
}

// Get returns a Image entity by its id.
func (c *ImageClient) Get(ctx context.Context, id int) (*Image, error) {
	return c.Query().Where(image.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ImageClient) GetX(ctx context.Context, id int) *Image {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySizes queries the sizes edge of a Image.
func (c *ImageClient) QuerySizes(i *Image) *ImageSizeQuery {
	query := (&ImageSizeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(image.Table, image.FieldID, id),
			sqlgraph.To(imagesize.Table, imagesize.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, image.SizesTable, image.SizesColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ImageClient) Hooks() []Hook {
	return c.hooks.Image
}

// Interceptors returns the client interceptors.
func (c *ImageClient) Interceptors() []Interceptor {
	return c.inters.Image
}

func (c *ImageClient) mutate(ctx context.Context, m *ImageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ImageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ImageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ImageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Image mutation op: %q", m.Op())
	}
}

// ImageSizeClient is a client for the ImageSize schema.
type ImageSizeClient struct {
	config
}

// NewImageSizeClient returns a client for the ImageSize from the given config.
func NewImageSizeClient(c config) *ImageSizeClient {
	return &ImageSizeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `imagesize.Hooks(f(g(h())))`.
func (c *ImageSizeClient) Use(hooks ...Hook) {
	c.hooks.ImageSize = append(c.hooks.ImageSize, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `imagesize.Intercept(f(g(h())))`.
func (c *ImageSizeClient) Intercept(interceptors ...Interceptor) {
	c.inters.ImageSize = append(c.inters.ImageSize, interceptors...)
}

// Create returns a builder for creating a ImageSize entity.
func (c *ImageSizeClient) Create() *ImageSizeCreate {
	mutation := newImageSizeMutation(c.config, OpCreate)
	return &ImageSizeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ImageSize entities.
func (c *ImageSizeClient) CreateBulk(builders ...*ImageSizeCreate) *ImageSizeCreateBulk {
	return &ImageSizeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ImageSizeClient) MapCreateBulk(slice any, setFunc func(*ImageSizeCreate, int)) *ImageSizeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ImageSizeCreateBulk{err: fmt.Errorf("calling to ImageSizeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ImageSizeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ImageSizeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ImageSize.
func (c *ImageSizeClient) Update() *ImageSizeUpdate {
	mutation := newImageSizeMutation(c.config, OpUpdate)
	return &ImageSizeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ImageSizeClient) UpdateOne(is *ImageSize) *ImageSizeUpdateOne {
	mutation := newImageSizeMutation(c.config, OpUpdateOne, withImageSize(is))
	return &ImageSizeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ImageSizeClient) UpdateOneID(id int) *ImageSizeUpdateOne {
	mutation := newImageSizeMutation(c.config, OpUpdateOne, withImageSizeID(id))
	return &ImageSizeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ImageSize.
func (c *ImageSizeClient) Delete() *ImageSizeDelete {
	mutation := newImageSizeMutation(c.config, OpDelete)
	return &ImageSizeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ImageSizeClient) DeleteOne(is *ImageSize) *ImageSizeDeleteOne {
	return c.DeleteOneID(is.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ImageSizeClient) DeleteOneID(id int) *ImageSizeDeleteOne {
	builder := c.Delete().Where(imagesize.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ImageSizeDeleteOne{builder}
}

// Query returns a query builder for ImageSize.
func (c *ImageSizeClient) Query() *ImageSizeQuery {
	return &ImageSizeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeImageSize},
		inters: c.Interceptors(),
	}
}

// Get returns a ImageSize entity by its id.
func (c *ImageSizeClient) Get(ctx context.Context, id int) (*ImageSize, error) {
	return c.Query().Where(imagesize.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ImageSizeClient) GetX(ctx context.Context, id int) *ImageSize {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFile queries the file edge of a ImageSize.
func (c *ImageSizeClient) QueryFile(is *ImageSize) *FileStorageQuery {
	query := (&FileStorageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := is.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(imagesize.Table, imagesize.FieldID, id),
			sqlgraph.To(filestorage.Table, filestorage.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, imagesize.FileTable, imagesize.FileColumn),
		)
		fromV = sqlgraph.Neighbors(is.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImage queries the image edge of a ImageSize.
func (c *ImageSizeClient) QueryImage(is *ImageSize) *ImageQuery {
	query := (&ImageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := is.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(imagesize.Table, imagesize.FieldID, id),
			sqlgraph.To(image.Table, image.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, imagesize.ImageTable, imagesize.ImageColumn),
		)
		fromV = sqlgraph.Neighbors(is.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ImageSizeClient) Hooks() []Hook {
	return c.hooks.ImageSize
}

// Interceptors returns the client interceptors.
func (c *ImageSizeClient) Interceptors() []Interceptor {
	return c.inters.ImageSize
}

func (c *ImageSizeClient) mutate(ctx context.Context, m *ImageSizeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ImageSizeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ImageSizeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ImageSizeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ImageSizeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ImageSize mutation op: %q", m.Op())
	}
}

// InvitationClient is a client for the Invitation schema.
type InvitationClient struct {
	config
}

// NewInvitationClient returns a client for the Invitation from the given config.
func NewInvitationClient(c config) *InvitationClient {
	return &InvitationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invitation.Hooks(f(g(h())))`.
func (c *InvitationClient) Use(hooks ...Hook) {
	c.hooks.Invitation = append(c.hooks.Invitation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invitation.Intercept(f(g(h())))`.
func (c *InvitationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Invitation = append(c.inters.Invitation, interceptors...)
}

// Create returns a builder for creating a Invitation entity.
func (c *InvitationClient) Create() *InvitationCreate {
	mutation := newInvitationMutation(c.config, OpCreate)
	return &InvitationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Invitation entities.
func (c *InvitationClient) CreateBulk(builders ...*InvitationCreate) *InvitationCreateBulk {
	return &InvitationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvitationClient) MapCreateBulk(slice any, setFunc func(*InvitationCreate, int)) *InvitationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvitationCreateBulk{err: fmt.Errorf("calling to InvitationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvitationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvitationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Invitation.
func (c *InvitationClient) Update() *InvitationUpdate {
	mutation := newInvitationMutation(c.config, OpUpdate)
	return &InvitationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvitationClient) UpdateOne(i *Invitation) *InvitationUpdateOne {
	mutation := newInvitationMutation(c.config, OpUpdateOne, withInvitation(i))
	return &InvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvitationClient) UpdateOneID(id int) *InvitationUpdateOne {
	mutation := newInvitationMutation(c.config, OpUpdateOne, withInvitationID(id))
	return &InvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Invitation.
func (c *InvitationClient) Delete() *InvitationDelete {
	mutation := newInvitationMutation(c.config, OpDelete)
	return &InvitationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvitationClient) DeleteOne(i *Invitation) *InvitationDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvitationClient) DeleteOneID(id int) *InvitationDeleteOne {
	builder := c.Delete().Where(invitation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvitationDeleteOne{builder}
}

// Query returns a query builder for Invitation.
func (c *InvitationClient) Query() *InvitationQuery {
	return &InvitationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvitation},
		inters: c.Interceptors(),
	}
}

// Get returns a Invitation entity by its id.
func (c *InvitationClient) Get(ctx context.Context, id int) (*Invitation, error) {
	return c.Query().Where(invitation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvitationClient) GetX(ctx context.Context, id int) *Invitation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInviter queries the inviter edge of a Invitation.
func (c *InvitationClient) QueryInviter(i *Invitation) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invitation.Table, invitation.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invitation.InviterTable, invitation.InviterColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InvitationClient) Hooks() []Hook {
	return c.hooks.Invitation
}

// Interceptors returns the client interceptors.
func (c *InvitationClient) Interceptors() []Interceptor {
	return c.inters.Invitation
}

func (c *InvitationClient) mutate(ctx context.Context, m *InvitationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvitationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvitationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvitationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Invitation mutation op: %q", m.Op())
	}
}

// LastSeenOnlineClient is a client for the LastSeenOnline schema.
type LastSeenOnlineClient struct {
	config
}

// NewLastSeenOnlineClient returns a client for the LastSeenOnline from the given config.
func NewLastSeenOnlineClient(c config) *LastSeenOnlineClient {
	return &LastSeenOnlineClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lastseenonline.Hooks(f(g(h())))`.
func (c *LastSeenOnlineClient) Use(hooks ...Hook) {
	c.hooks.LastSeenOnline = append(c.hooks.LastSeenOnline, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lastseenonline.Intercept(f(g(h())))`.
func (c *LastSeenOnlineClient) Intercept(interceptors ...Interceptor) {
	c.inters.LastSeenOnline = append(c.inters.LastSeenOnline, interceptors...)
}

// Create returns a builder for creating a LastSeenOnline entity.
func (c *LastSeenOnlineClient) Create() *LastSeenOnlineCreate {
	mutation := newLastSeenOnlineMutation(c.config, OpCreate)
	return &LastSeenOnlineCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LastSeenOnline entities.
func (c *LastSeenOnlineClient) CreateBulk(builders ...*LastSeenOnlineCreate) *LastSeenOnlineCreateBulk {
	return &LastSeenOnlineCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LastSeenOnlineClient) MapCreateBulk(slice any, setFunc func(*LastSeenOnlineCreate, int)) *LastSeenOnlineCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LastSeenOnlineCreateBulk{err: fmt.Errorf("calling to LastSeenOnlineClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LastSeenOnlineCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LastSeenOnlineCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LastSeenOnline.
func (c *LastSeenOnlineClient) Update() *LastSeenOnlineUpdate {
	mutation := newLastSeenOnlineMutation(c.config, OpUpdate)
	return &LastSeenOnlineUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LastSeenOnlineClient) UpdateOne(lso *LastSeenOnline) *LastSeenOnlineUpdateOne {
	mutation := newLastSeenOnlineMutation(c.config, OpUpdateOne, withLastSeenOnline(lso))
	return &LastSeenOnlineUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LastSeenOnlineClient) UpdateOneID(id int) *LastSeenOnlineUpdateOne {
	mutation := newLastSeenOnlineMutation(c.config, OpUpdateOne, withLastSeenOnlineID(id))
	return &LastSeenOnlineUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LastSeenOnline.
func (c *LastSeenOnlineClient) Delete() *LastSeenOnlineDelete {
	mutation := newLastSeenOnlineMutation(c.config, OpDelete)
	return &LastSeenOnlineDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LastSeenOnlineClient) DeleteOne(lso *LastSeenOnline) *LastSeenOnlineDeleteOne {
	return c.DeleteOneID(lso.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LastSeenOnlineClient) DeleteOneID(id int) *LastSeenOnlineDeleteOne {
	builder := c.Delete().Where(lastseenonline.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LastSeenOnlineDeleteOne{builder}
}

// Query returns a query builder for LastSeenOnline.
func (c *LastSeenOnlineClient) Query() *LastSeenOnlineQuery {
	return &LastSeenOnlineQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLastSeenOnline},
		inters: c.Interceptors(),
	}
}

// Get returns a LastSeenOnline entity by its id.
func (c *LastSeenOnlineClient) Get(ctx context.Context, id int) (*LastSeenOnline, error) {
	return c.Query().Where(lastseenonline.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LastSeenOnlineClient) GetX(ctx context.Context, id int) *LastSeenOnline {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a LastSeenOnline.
func (c *LastSeenOnlineClient) QueryUser(lso *LastSeenOnline) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lso.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lastseenonline.Table, lastseenonline.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lastseenonline.UserTable, lastseenonline.UserColumn),
		)
		fromV = sqlgraph.Neighbors(lso.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LastSeenOnlineClient) Hooks() []Hook {
	return c.hooks.LastSeenOnline
}

// Interceptors returns the client interceptors.
func (c *LastSeenOnlineClient) Interceptors() []Interceptor {
	return c.inters.LastSeenOnline
}

func (c *LastSeenOnlineClient) mutate(ctx context.Context, m *LastSeenOnlineMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LastSeenOnlineCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LastSeenOnlineUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LastSeenOnlineUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LastSeenOnlineDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LastSeenOnline mutation op: %q", m.Op())
	}
}

// MonthlySubscriptionClient is a client for the MonthlySubscription schema.
type MonthlySubscriptionClient struct {
	config
}

// NewMonthlySubscriptionClient returns a client for the MonthlySubscription from the given config.
func NewMonthlySubscriptionClient(c config) *MonthlySubscriptionClient {
	return &MonthlySubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `monthlysubscription.Hooks(f(g(h())))`.
func (c *MonthlySubscriptionClient) Use(hooks ...Hook) {
	c.hooks.MonthlySubscription = append(c.hooks.MonthlySubscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `monthlysubscription.Intercept(f(g(h())))`.
func (c *MonthlySubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MonthlySubscription = append(c.inters.MonthlySubscription, interceptors...)
}

// Create returns a builder for creating a MonthlySubscription entity.
func (c *MonthlySubscriptionClient) Create() *MonthlySubscriptionCreate {
	mutation := newMonthlySubscriptionMutation(c.config, OpCreate)
	return &MonthlySubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MonthlySubscription entities.
func (c *MonthlySubscriptionClient) CreateBulk(builders ...*MonthlySubscriptionCreate) *MonthlySubscriptionCreateBulk {
	return &MonthlySubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MonthlySubscriptionClient) MapCreateBulk(slice any, setFunc func(*MonthlySubscriptionCreate, int)) *MonthlySubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MonthlySubscriptionCreateBulk{err: fmt.Errorf("calling to MonthlySubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MonthlySubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MonthlySubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MonthlySubscription.
func (c *MonthlySubscriptionClient) Update() *MonthlySubscriptionUpdate {
	mutation := newMonthlySubscriptionMutation(c.config, OpUpdate)
	return &MonthlySubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MonthlySubscriptionClient) UpdateOne(ms *MonthlySubscription) *MonthlySubscriptionUpdateOne {
	mutation := newMonthlySubscriptionMutation(c.config, OpUpdateOne, withMonthlySubscription(ms))
	return &MonthlySubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MonthlySubscriptionClient) UpdateOneID(id int) *MonthlySubscriptionUpdateOne {
	mutation := newMonthlySubscriptionMutation(c.config, OpUpdateOne, withMonthlySubscriptionID(id))
	return &MonthlySubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MonthlySubscription.
func (c *MonthlySubscriptionClient) Delete() *MonthlySubscriptionDelete {
	mutation := newMonthlySubscriptionMutation(c.config, OpDelete)
	return &MonthlySubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MonthlySubscriptionClient) DeleteOne(ms *MonthlySubscription) *MonthlySubscriptionDeleteOne {
	return c.DeleteOneID(ms.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MonthlySubscriptionClient) DeleteOneID(id int) *MonthlySubscriptionDeleteOne {
	builder := c.Delete().Where(monthlysubscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MonthlySubscriptionDeleteOne{builder}
}

// Query returns a query builder for MonthlySubscription.
func (c *MonthlySubscriptionClient) Query() *MonthlySubscriptionQuery {
	return &MonthlySubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMonthlySubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a MonthlySubscription entity by its id.
func (c *MonthlySubscriptionClient) Get(ctx context.Context, id int) (*MonthlySubscription, error) {
	return c.Query().Where(monthlysubscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MonthlySubscriptionClient) GetX(ctx context.Context, id int) *MonthlySubscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBenefactors queries the benefactors edge of a MonthlySubscription.
func (c *MonthlySubscriptionClient) QueryBenefactors(ms *MonthlySubscription) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ms.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(monthlysubscription.Table, monthlysubscription.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, monthlysubscription.BenefactorsTable, monthlysubscription.BenefactorsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ms.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPayer queries the payer edge of a MonthlySubscription.
func (c *MonthlySubscriptionClient) QueryPayer(ms *MonthlySubscription) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ms.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(monthlysubscription.Table, monthlysubscription.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, monthlysubscription.PayerTable, monthlysubscription.PayerColumn),
		)
		fromV = sqlgraph.Neighbors(ms.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MonthlySubscriptionClient) Hooks() []Hook {
	return c.hooks.MonthlySubscription
}

// Interceptors returns the client interceptors.
func (c *MonthlySubscriptionClient) Interceptors() []Interceptor {
	return c.inters.MonthlySubscription
}

func (c *MonthlySubscriptionClient) mutate(ctx context.Context, m *MonthlySubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MonthlySubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MonthlySubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MonthlySubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MonthlySubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MonthlySubscription mutation op: %q", m.Op())
	}
}

// NotificationClient is a client for the Notification schema.
type NotificationClient struct {
	config
}

// NewNotificationClient returns a client for the Notification from the given config.
func NewNotificationClient(c config) *NotificationClient {
	return &NotificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notification.Hooks(f(g(h())))`.
func (c *NotificationClient) Use(hooks ...Hook) {
	c.hooks.Notification = append(c.hooks.Notification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notification.Intercept(f(g(h())))`.
func (c *NotificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Notification = append(c.inters.Notification, interceptors...)
}

// Create returns a builder for creating a Notification entity.
func (c *NotificationClient) Create() *NotificationCreate {
	mutation := newNotificationMutation(c.config, OpCreate)
	return &NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Notification entities.
func (c *NotificationClient) CreateBulk(builders ...*NotificationCreate) *NotificationCreateBulk {
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationClient) MapCreateBulk(slice any, setFunc func(*NotificationCreate, int)) *NotificationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationCreateBulk{err: fmt.Errorf("calling to NotificationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Notification.
func (c *NotificationClient) Update() *NotificationUpdate {
	mutation := newNotificationMutation(c.config, OpUpdate)
	return &NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationClient) UpdateOne(n *Notification) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotification(n))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationClient) UpdateOneID(id int) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotificationID(id))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Notification.
func (c *NotificationClient) Delete() *NotificationDelete {
	mutation := newNotificationMutation(c.config, OpDelete)
	return &NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationClient) DeleteOne(n *Notification) *NotificationDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationClient) DeleteOneID(id int) *NotificationDeleteOne {
	builder := c.Delete().Where(notification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationDeleteOne{builder}
}

// Query returns a query builder for Notification.
func (c *NotificationClient) Query() *NotificationQuery {
	return &NotificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotification},
		inters: c.Interceptors(),
	}
}

// Get returns a Notification entity by its id.
func (c *NotificationClient) Get(ctx context.Context, id int) (*Notification, error) {
	return c.Query().Where(notification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationClient) GetX(ctx context.Context, id int) *Notification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a Notification.
func (c *NotificationClient) QueryProfile(n *Notification) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notification.ProfileTable, notification.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NotificationClient) Hooks() []Hook {
	hooks := c.hooks.Notification
	return append(hooks[:len(hooks):len(hooks)], notification.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *NotificationClient) Interceptors() []Interceptor {
	return c.inters.Notification
}

func (c *NotificationClient) mutate(ctx context.Context, m *NotificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Notification mutation op: %q", m.Op())
	}
}

// NotificationPermissionClient is a client for the NotificationPermission schema.
type NotificationPermissionClient struct {
	config
}

// NewNotificationPermissionClient returns a client for the NotificationPermission from the given config.
func NewNotificationPermissionClient(c config) *NotificationPermissionClient {
	return &NotificationPermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notificationpermission.Hooks(f(g(h())))`.
func (c *NotificationPermissionClient) Use(hooks ...Hook) {
	c.hooks.NotificationPermission = append(c.hooks.NotificationPermission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notificationpermission.Intercept(f(g(h())))`.
func (c *NotificationPermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.NotificationPermission = append(c.inters.NotificationPermission, interceptors...)
}

// Create returns a builder for creating a NotificationPermission entity.
func (c *NotificationPermissionClient) Create() *NotificationPermissionCreate {
	mutation := newNotificationPermissionMutation(c.config, OpCreate)
	return &NotificationPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NotificationPermission entities.
func (c *NotificationPermissionClient) CreateBulk(builders ...*NotificationPermissionCreate) *NotificationPermissionCreateBulk {
	return &NotificationPermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationPermissionClient) MapCreateBulk(slice any, setFunc func(*NotificationPermissionCreate, int)) *NotificationPermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationPermissionCreateBulk{err: fmt.Errorf("calling to NotificationPermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationPermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationPermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NotificationPermission.
func (c *NotificationPermissionClient) Update() *NotificationPermissionUpdate {
	mutation := newNotificationPermissionMutation(c.config, OpUpdate)
	return &NotificationPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationPermissionClient) UpdateOne(np *NotificationPermission) *NotificationPermissionUpdateOne {
	mutation := newNotificationPermissionMutation(c.config, OpUpdateOne, withNotificationPermission(np))
	return &NotificationPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationPermissionClient) UpdateOneID(id int) *NotificationPermissionUpdateOne {
	mutation := newNotificationPermissionMutation(c.config, OpUpdateOne, withNotificationPermissionID(id))
	return &NotificationPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NotificationPermission.
func (c *NotificationPermissionClient) Delete() *NotificationPermissionDelete {
	mutation := newNotificationPermissionMutation(c.config, OpDelete)
	return &NotificationPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationPermissionClient) DeleteOne(np *NotificationPermission) *NotificationPermissionDeleteOne {
	return c.DeleteOneID(np.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationPermissionClient) DeleteOneID(id int) *NotificationPermissionDeleteOne {
	builder := c.Delete().Where(notificationpermission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationPermissionDeleteOne{builder}
}

// Query returns a query builder for NotificationPermission.
func (c *NotificationPermissionClient) Query() *NotificationPermissionQuery {
	return &NotificationPermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotificationPermission},
		inters: c.Interceptors(),
	}
}

// Get returns a NotificationPermission entity by its id.
func (c *NotificationPermissionClient) Get(ctx context.Context, id int) (*NotificationPermission, error) {
	return c.Query().Where(notificationpermission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationPermissionClient) GetX(ctx context.Context, id int) *NotificationPermission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a NotificationPermission.
func (c *NotificationPermissionClient) QueryProfile(np *NotificationPermission) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := np.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notificationpermission.Table, notificationpermission.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notificationpermission.ProfileTable, notificationpermission.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(np.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NotificationPermissionClient) Hooks() []Hook {
	return c.hooks.NotificationPermission
}

// Interceptors returns the client interceptors.
func (c *NotificationPermissionClient) Interceptors() []Interceptor {
	return c.inters.NotificationPermission
}

func (c *NotificationPermissionClient) mutate(ctx context.Context, m *NotificationPermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NotificationPermission mutation op: %q", m.Op())
	}
}

// NotificationTimeClient is a client for the NotificationTime schema.
type NotificationTimeClient struct {
	config
}

// NewNotificationTimeClient returns a client for the NotificationTime from the given config.
func NewNotificationTimeClient(c config) *NotificationTimeClient {
	return &NotificationTimeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notificationtime.Hooks(f(g(h())))`.
func (c *NotificationTimeClient) Use(hooks ...Hook) {
	c.hooks.NotificationTime = append(c.hooks.NotificationTime, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notificationtime.Intercept(f(g(h())))`.
func (c *NotificationTimeClient) Intercept(interceptors ...Interceptor) {
	c.inters.NotificationTime = append(c.inters.NotificationTime, interceptors...)
}

// Create returns a builder for creating a NotificationTime entity.
func (c *NotificationTimeClient) Create() *NotificationTimeCreate {
	mutation := newNotificationTimeMutation(c.config, OpCreate)
	return &NotificationTimeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NotificationTime entities.
func (c *NotificationTimeClient) CreateBulk(builders ...*NotificationTimeCreate) *NotificationTimeCreateBulk {
	return &NotificationTimeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationTimeClient) MapCreateBulk(slice any, setFunc func(*NotificationTimeCreate, int)) *NotificationTimeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationTimeCreateBulk{err: fmt.Errorf("calling to NotificationTimeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationTimeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationTimeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NotificationTime.
func (c *NotificationTimeClient) Update() *NotificationTimeUpdate {
	mutation := newNotificationTimeMutation(c.config, OpUpdate)
	return &NotificationTimeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationTimeClient) UpdateOne(nt *NotificationTime) *NotificationTimeUpdateOne {
	mutation := newNotificationTimeMutation(c.config, OpUpdateOne, withNotificationTime(nt))
	return &NotificationTimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationTimeClient) UpdateOneID(id int) *NotificationTimeUpdateOne {
	mutation := newNotificationTimeMutation(c.config, OpUpdateOne, withNotificationTimeID(id))
	return &NotificationTimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NotificationTime.
func (c *NotificationTimeClient) Delete() *NotificationTimeDelete {
	mutation := newNotificationTimeMutation(c.config, OpDelete)
	return &NotificationTimeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationTimeClient) DeleteOne(nt *NotificationTime) *NotificationTimeDeleteOne {
	return c.DeleteOneID(nt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationTimeClient) DeleteOneID(id int) *NotificationTimeDeleteOne {
	builder := c.Delete().Where(notificationtime.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationTimeDeleteOne{builder}
}

// Query returns a query builder for NotificationTime.
func (c *NotificationTimeClient) Query() *NotificationTimeQuery {
	return &NotificationTimeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotificationTime},
		inters: c.Interceptors(),
	}
}

// Get returns a NotificationTime entity by its id.
func (c *NotificationTimeClient) Get(ctx context.Context, id int) (*NotificationTime, error) {
	return c.Query().Where(notificationtime.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationTimeClient) GetX(ctx context.Context, id int) *NotificationTime {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a NotificationTime.
func (c *NotificationTimeClient) QueryProfile(nt *NotificationTime) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := nt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notificationtime.Table, notificationtime.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notificationtime.ProfileTable, notificationtime.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(nt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NotificationTimeClient) Hooks() []Hook {
	return c.hooks.NotificationTime
}

// Interceptors returns the client interceptors.
func (c *NotificationTimeClient) Interceptors() []Interceptor {
	return c.inters.NotificationTime
}

func (c *NotificationTimeClient) mutate(ctx context.Context, m *NotificationTimeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationTimeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationTimeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationTimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationTimeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NotificationTime mutation op: %q", m.Op())
	}
}

// PasswordTokenClient is a client for the PasswordToken schema.
type PasswordTokenClient struct {
	config
}

// NewPasswordTokenClient returns a client for the PasswordToken from the given config.
func NewPasswordTokenClient(c config) *PasswordTokenClient {
	return &PasswordTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `passwordtoken.Hooks(f(g(h())))`.
func (c *PasswordTokenClient) Use(hooks ...Hook) {
	c.hooks.PasswordToken = append(c.hooks.PasswordToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `passwordtoken.Intercept(f(g(h())))`.
func (c *PasswordTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.PasswordToken = append(c.inters.PasswordToken, interceptors...)
}

// Create returns a builder for creating a PasswordToken entity.
func (c *PasswordTokenClient) Create() *PasswordTokenCreate {
	mutation := newPasswordTokenMutation(c.config, OpCreate)
	return &PasswordTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PasswordToken entities.
func (c *PasswordTokenClient) CreateBulk(builders ...*PasswordTokenCreate) *PasswordTokenCreateBulk {
	return &PasswordTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PasswordTokenClient) MapCreateBulk(slice any, setFunc func(*PasswordTokenCreate, int)) *PasswordTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PasswordTokenCreateBulk{err: fmt.Errorf("calling to PasswordTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PasswordTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PasswordTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PasswordToken.
func (c *PasswordTokenClient) Update() *PasswordTokenUpdate {
	mutation := newPasswordTokenMutation(c.config, OpUpdate)
	return &PasswordTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PasswordTokenClient) UpdateOne(pt *PasswordToken) *PasswordTokenUpdateOne {
	mutation := newPasswordTokenMutation(c.config, OpUpdateOne, withPasswordToken(pt))
	return &PasswordTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PasswordTokenClient) UpdateOneID(id int) *PasswordTokenUpdateOne {
	mutation := newPasswordTokenMutation(c.config, OpUpdateOne, withPasswordTokenID(id))
	return &PasswordTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PasswordToken.
func (c *PasswordTokenClient) Delete() *PasswordTokenDelete {
	mutation := newPasswordTokenMutation(c.config, OpDelete)
	return &PasswordTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PasswordTokenClient) DeleteOne(pt *PasswordToken) *PasswordTokenDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PasswordTokenClient) DeleteOneID(id int) *PasswordTokenDeleteOne {
	builder := c.Delete().Where(passwordtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PasswordTokenDeleteOne{builder}
}

// Query returns a query builder for PasswordToken.
func (c *PasswordTokenClient) Query() *PasswordTokenQuery {
	return &PasswordTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePasswordToken},
		inters: c.Interceptors(),
	}
}

// Get returns a PasswordToken entity by its id.
func (c *PasswordTokenClient) Get(ctx context.Context, id int) (*PasswordToken, error) {
	return c.Query().Where(passwordtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PasswordTokenClient) GetX(ctx context.Context, id int) *PasswordToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a PasswordToken.
func (c *PasswordTokenClient) QueryUser(pt *PasswordToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(passwordtoken.Table, passwordtoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, passwordtoken.UserTable, passwordtoken.UserColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PasswordTokenClient) Hooks() []Hook {
	return c.hooks.PasswordToken
}

// Interceptors returns the client interceptors.
func (c *PasswordTokenClient) Interceptors() []Interceptor {
	return c.inters.PasswordToken
}

func (c *PasswordTokenClient) mutate(ctx context.Context, m *PasswordTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PasswordTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PasswordTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PasswordTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PasswordTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PasswordToken mutation op: %q", m.Op())
	}
}

// PhoneVerificationCodeClient is a client for the PhoneVerificationCode schema.
type PhoneVerificationCodeClient struct {
	config
}

// NewPhoneVerificationCodeClient returns a client for the PhoneVerificationCode from the given config.
func NewPhoneVerificationCodeClient(c config) *PhoneVerificationCodeClient {
	return &PhoneVerificationCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `phoneverificationcode.Hooks(f(g(h())))`.
func (c *PhoneVerificationCodeClient) Use(hooks ...Hook) {
	c.hooks.PhoneVerificationCode = append(c.hooks.PhoneVerificationCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `phoneverificationcode.Intercept(f(g(h())))`.
func (c *PhoneVerificationCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.PhoneVerificationCode = append(c.inters.PhoneVerificationCode, interceptors...)
}

// Create returns a builder for creating a PhoneVerificationCode entity.
func (c *PhoneVerificationCodeClient) Create() *PhoneVerificationCodeCreate {
	mutation := newPhoneVerificationCodeMutation(c.config, OpCreate)
	return &PhoneVerificationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PhoneVerificationCode entities.
func (c *PhoneVerificationCodeClient) CreateBulk(builders ...*PhoneVerificationCodeCreate) *PhoneVerificationCodeCreateBulk {
	return &PhoneVerificationCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PhoneVerificationCodeClient) MapCreateBulk(slice any, setFunc func(*PhoneVerificationCodeCreate, int)) *PhoneVerificationCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PhoneVerificationCodeCreateBulk{err: fmt.Errorf("calling to PhoneVerificationCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PhoneVerificationCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PhoneVerificationCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PhoneVerificationCode.
func (c *PhoneVerificationCodeClient) Update() *PhoneVerificationCodeUpdate {
	mutation := newPhoneVerificationCodeMutation(c.config, OpUpdate)
	return &PhoneVerificationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PhoneVerificationCodeClient) UpdateOne(pvc *PhoneVerificationCode) *PhoneVerificationCodeUpdateOne {
	mutation := newPhoneVerificationCodeMutation(c.config, OpUpdateOne, withPhoneVerificationCode(pvc))
	return &PhoneVerificationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PhoneVerificationCodeClient) UpdateOneID(id int) *PhoneVerificationCodeUpdateOne {
	mutation := newPhoneVerificationCodeMutation(c.config, OpUpdateOne, withPhoneVerificationCodeID(id))
	return &PhoneVerificationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PhoneVerificationCode.
func (c *PhoneVerificationCodeClient) Delete() *PhoneVerificationCodeDelete {
	mutation := newPhoneVerificationCodeMutation(c.config, OpDelete)
	return &PhoneVerificationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PhoneVerificationCodeClient) DeleteOne(pvc *PhoneVerificationCode) *PhoneVerificationCodeDeleteOne {
	return c.DeleteOneID(pvc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PhoneVerificationCodeClient) DeleteOneID(id int) *PhoneVerificationCodeDeleteOne {
	builder := c.Delete().Where(phoneverificationcode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PhoneVerificationCodeDeleteOne{builder}
}

// Query returns a query builder for PhoneVerificationCode.
func (c *PhoneVerificationCodeClient) Query() *PhoneVerificationCodeQuery {
	return &PhoneVerificationCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePhoneVerificationCode},
		inters: c.Interceptors(),
	}
}

// Get returns a PhoneVerificationCode entity by its id.
func (c *PhoneVerificationCodeClient) Get(ctx context.Context, id int) (*PhoneVerificationCode, error) {
	return c.Query().Where(phoneverificationcode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PhoneVerificationCodeClient) GetX(ctx context.Context, id int) *PhoneVerificationCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a PhoneVerificationCode.
func (c *PhoneVerificationCodeClient) QueryProfile(pvc *PhoneVerificationCode) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pvc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(phoneverificationcode.Table, phoneverificationcode.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, phoneverificationcode.ProfileTable, phoneverificationcode.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(pvc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PhoneVerificationCodeClient) Hooks() []Hook {
	return c.hooks.PhoneVerificationCode
}

// Interceptors returns the client interceptors.
func (c *PhoneVerificationCodeClient) Interceptors() []Interceptor {
	return c.inters.PhoneVerificationCode
}

func (c *PhoneVerificationCodeClient) mutate(ctx context.Context, m *PhoneVerificationCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PhoneVerificationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PhoneVerificationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PhoneVerificationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PhoneVerificationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PhoneVerificationCode mutation op: %q", m.Op())
	}
}

// ProfileClient is a client for the Profile schema.
type ProfileClient struct {
	config
}

// NewProfileClient returns a client for the Profile from the given config.
func NewProfileClient(c config) *ProfileClient {
	return &ProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profile.Hooks(f(g(h())))`.
func (c *ProfileClient) Use(hooks ...Hook) {
	c.hooks.Profile = append(c.hooks.Profile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `profile.Intercept(f(g(h())))`.
func (c *ProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.Profile = append(c.inters.Profile, interceptors...)
}

// Create returns a builder for creating a Profile entity.
func (c *ProfileClient) Create() *ProfileCreate {
	mutation := newProfileMutation(c.config, OpCreate)
	return &ProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Profile entities.
func (c *ProfileClient) CreateBulk(builders ...*ProfileCreate) *ProfileCreateBulk {
	return &ProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProfileClient) MapCreateBulk(slice any, setFunc func(*ProfileCreate, int)) *ProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProfileCreateBulk{err: fmt.Errorf("calling to ProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Profile.
func (c *ProfileClient) Update() *ProfileUpdate {
	mutation := newProfileMutation(c.config, OpUpdate)
	return &ProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfileClient) UpdateOne(pr *Profile) *ProfileUpdateOne {
	mutation := newProfileMutation(c.config, OpUpdateOne, withProfile(pr))
	return &ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfileClient) UpdateOneID(id int) *ProfileUpdateOne {
	mutation := newProfileMutation(c.config, OpUpdateOne, withProfileID(id))
	return &ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Profile.
func (c *ProfileClient) Delete() *ProfileDelete {
	mutation := newProfileMutation(c.config, OpDelete)
	return &ProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProfileClient) DeleteOne(pr *Profile) *ProfileDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProfileClient) DeleteOneID(id int) *ProfileDeleteOne {
	builder := c.Delete().Where(profile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfileDeleteOne{builder}
}

// Query returns a query builder for Profile.
func (c *ProfileClient) Query() *ProfileQuery {
	return &ProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a Profile entity by its id.
func (c *ProfileClient) Get(ctx context.Context, id int) (*Profile, error) {
	return c.Query().Where(profile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfileClient) GetX(ctx context.Context, id int) *Profile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFriends queries the friends edge of a Profile.
func (c *ProfileClient) QueryFriends(pr *Profile) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, profile.FriendsTable, profile.FriendsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPhotos queries the photos edge of a Profile.
func (c *ProfileClient) QueryPhotos(pr *Profile) *ImageQuery {
	query := (&ImageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(image.Table, image.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profile.PhotosTable, profile.PhotosColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfileImage queries the profile_image edge of a Profile.
func (c *ProfileClient) QueryProfileImage(pr *Profile) *ImageQuery {
	query := (&ImageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(image.Table, image.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, profile.ProfileImageTable, profile.ProfileImageColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a Profile.
func (c *ProfileClient) QueryNotifications(pr *Profile) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profile.NotificationsTable, profile.NotificationsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvitations queries the invitations edge of a Profile.
func (c *ProfileClient) QueryInvitations(pr *Profile) *InvitationQuery {
	query := (&InvitationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(invitation.Table, invitation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profile.InvitationsTable, profile.InvitationsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFcmPushSubscriptions queries the fcm_push_subscriptions edge of a Profile.
func (c *ProfileClient) QueryFcmPushSubscriptions(pr *Profile) *FCMSubscriptionsQuery {
	query := (&FCMSubscriptionsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(fcmsubscriptions.Table, fcmsubscriptions.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profile.FcmPushSubscriptionsTable, profile.FcmPushSubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPwaPushSubscriptions queries the pwa_push_subscriptions edge of a Profile.
func (c *ProfileClient) QueryPwaPushSubscriptions(pr *Profile) *PwaPushSubscriptionQuery {
	query := (&PwaPushSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(pwapushsubscription.Table, pwapushsubscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profile.PwaPushSubscriptionsTable, profile.PwaPushSubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotificationPermissions queries the notification_permissions edge of a Profile.
func (c *ProfileClient) QueryNotificationPermissions(pr *Profile) *NotificationPermissionQuery {
	query := (&NotificationPermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(notificationpermission.Table, notificationpermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profile.NotificationPermissionsTable, profile.NotificationPermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotificationTimes queries the notification_times edge of a Profile.
func (c *ProfileClient) QueryNotificationTimes(pr *Profile) *NotificationTimeQuery {
	query := (&NotificationTimeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(notificationtime.Table, notificationtime.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profile.NotificationTimesTable, profile.NotificationTimesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPhoneVerificationCode queries the phone_verification_code edge of a Profile.
func (c *ProfileClient) QueryPhoneVerificationCode(pr *Profile) *PhoneVerificationCodeQuery {
	query := (&PhoneVerificationCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(phoneverificationcode.Table, phoneverificationcode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profile.PhoneVerificationCodeTable, profile.PhoneVerificationCodeColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySentEmails queries the sent_emails edge of a Profile.
func (c *ProfileClient) QuerySentEmails(pr *Profile) *SentEmailQuery {
	query := (&SentEmailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(sentemail.Table, sentemail.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profile.SentEmailsTable, profile.SentEmailsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Profile.
func (c *ProfileClient) QueryUser(pr *Profile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, profile.UserTable, profile.UserColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscription queries the subscription edge of a Profile.
func (c *ProfileClient) QuerySubscription(pr *Profile) *MonthlySubscriptionQuery {
	query := (&MonthlySubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(monthlysubscription.Table, monthlysubscription.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, profile.SubscriptionTable, profile.SubscriptionPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfileClient) Hooks() []Hook {
	return c.hooks.Profile
}

// Interceptors returns the client interceptors.
func (c *ProfileClient) Interceptors() []Interceptor {
	return c.inters.Profile
}

func (c *ProfileClient) mutate(ctx context.Context, m *ProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Profile mutation op: %q", m.Op())
	}
}

// PwaPushSubscriptionClient is a client for the PwaPushSubscription schema.
type PwaPushSubscriptionClient struct {
	config
}

// NewPwaPushSubscriptionClient returns a client for the PwaPushSubscription from the given config.
func NewPwaPushSubscriptionClient(c config) *PwaPushSubscriptionClient {
	return &PwaPushSubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pwapushsubscription.Hooks(f(g(h())))`.
func (c *PwaPushSubscriptionClient) Use(hooks ...Hook) {
	c.hooks.PwaPushSubscription = append(c.hooks.PwaPushSubscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pwapushsubscription.Intercept(f(g(h())))`.
func (c *PwaPushSubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.PwaPushSubscription = append(c.inters.PwaPushSubscription, interceptors...)
}

// Create returns a builder for creating a PwaPushSubscription entity.
func (c *PwaPushSubscriptionClient) Create() *PwaPushSubscriptionCreate {
	mutation := newPwaPushSubscriptionMutation(c.config, OpCreate)
	return &PwaPushSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PwaPushSubscription entities.
func (c *PwaPushSubscriptionClient) CreateBulk(builders ...*PwaPushSubscriptionCreate) *PwaPushSubscriptionCreateBulk {
	return &PwaPushSubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PwaPushSubscriptionClient) MapCreateBulk(slice any, setFunc func(*PwaPushSubscriptionCreate, int)) *PwaPushSubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PwaPushSubscriptionCreateBulk{err: fmt.Errorf("calling to PwaPushSubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PwaPushSubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PwaPushSubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PwaPushSubscription.
func (c *PwaPushSubscriptionClient) Update() *PwaPushSubscriptionUpdate {
	mutation := newPwaPushSubscriptionMutation(c.config, OpUpdate)
	return &PwaPushSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PwaPushSubscriptionClient) UpdateOne(pps *PwaPushSubscription) *PwaPushSubscriptionUpdateOne {
	mutation := newPwaPushSubscriptionMutation(c.config, OpUpdateOne, withPwaPushSubscription(pps))
	return &PwaPushSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PwaPushSubscriptionClient) UpdateOneID(id int) *PwaPushSubscriptionUpdateOne {
	mutation := newPwaPushSubscriptionMutation(c.config, OpUpdateOne, withPwaPushSubscriptionID(id))
	return &PwaPushSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PwaPushSubscription.
func (c *PwaPushSubscriptionClient) Delete() *PwaPushSubscriptionDelete {
	mutation := newPwaPushSubscriptionMutation(c.config, OpDelete)
	return &PwaPushSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PwaPushSubscriptionClient) DeleteOne(pps *PwaPushSubscription) *PwaPushSubscriptionDeleteOne {
	return c.DeleteOneID(pps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PwaPushSubscriptionClient) DeleteOneID(id int) *PwaPushSubscriptionDeleteOne {
	builder := c.Delete().Where(pwapushsubscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PwaPushSubscriptionDeleteOne{builder}
}

// Query returns a query builder for PwaPushSubscription.
func (c *PwaPushSubscriptionClient) Query() *PwaPushSubscriptionQuery {
	return &PwaPushSubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePwaPushSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a PwaPushSubscription entity by its id.
func (c *PwaPushSubscriptionClient) Get(ctx context.Context, id int) (*PwaPushSubscription, error) {
	return c.Query().Where(pwapushsubscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PwaPushSubscriptionClient) GetX(ctx context.Context, id int) *PwaPushSubscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a PwaPushSubscription.
func (c *PwaPushSubscriptionClient) QueryProfile(pps *PwaPushSubscription) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pwapushsubscription.Table, pwapushsubscription.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pwapushsubscription.ProfileTable, pwapushsubscription.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(pps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PwaPushSubscriptionClient) Hooks() []Hook {
	return c.hooks.PwaPushSubscription
}

// Interceptors returns the client interceptors.
func (c *PwaPushSubscriptionClient) Interceptors() []Interceptor {
	return c.inters.PwaPushSubscription
}

func (c *PwaPushSubscriptionClient) mutate(ctx context.Context, m *PwaPushSubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PwaPushSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PwaPushSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PwaPushSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PwaPushSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PwaPushSubscription mutation op: %q", m.Op())
	}
}

// SentEmailClient is a client for the SentEmail schema.
type SentEmailClient struct {
	config
}

// NewSentEmailClient returns a client for the SentEmail from the given config.
func NewSentEmailClient(c config) *SentEmailClient {
	return &SentEmailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sentemail.Hooks(f(g(h())))`.
func (c *SentEmailClient) Use(hooks ...Hook) {
	c.hooks.SentEmail = append(c.hooks.SentEmail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sentemail.Intercept(f(g(h())))`.
func (c *SentEmailClient) Intercept(interceptors ...Interceptor) {
	c.inters.SentEmail = append(c.inters.SentEmail, interceptors...)
}

// Create returns a builder for creating a SentEmail entity.
func (c *SentEmailClient) Create() *SentEmailCreate {
	mutation := newSentEmailMutation(c.config, OpCreate)
	return &SentEmailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SentEmail entities.
func (c *SentEmailClient) CreateBulk(builders ...*SentEmailCreate) *SentEmailCreateBulk {
	return &SentEmailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SentEmailClient) MapCreateBulk(slice any, setFunc func(*SentEmailCreate, int)) *SentEmailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SentEmailCreateBulk{err: fmt.Errorf("calling to SentEmailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SentEmailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SentEmailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SentEmail.
func (c *SentEmailClient) Update() *SentEmailUpdate {
	mutation := newSentEmailMutation(c.config, OpUpdate)
	return &SentEmailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SentEmailClient) UpdateOne(se *SentEmail) *SentEmailUpdateOne {
	mutation := newSentEmailMutation(c.config, OpUpdateOne, withSentEmail(se))
	return &SentEmailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SentEmailClient) UpdateOneID(id int) *SentEmailUpdateOne {
	mutation := newSentEmailMutation(c.config, OpUpdateOne, withSentEmailID(id))
	return &SentEmailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SentEmail.
func (c *SentEmailClient) Delete() *SentEmailDelete {
	mutation := newSentEmailMutation(c.config, OpDelete)
	return &SentEmailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SentEmailClient) DeleteOne(se *SentEmail) *SentEmailDeleteOne {
	return c.DeleteOneID(se.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SentEmailClient) DeleteOneID(id int) *SentEmailDeleteOne {
	builder := c.Delete().Where(sentemail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SentEmailDeleteOne{builder}
}

// Query returns a query builder for SentEmail.
func (c *SentEmailClient) Query() *SentEmailQuery {
	return &SentEmailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSentEmail},
		inters: c.Interceptors(),
	}
}

// Get returns a SentEmail entity by its id.
func (c *SentEmailClient) Get(ctx context.Context, id int) (*SentEmail, error) {
	return c.Query().Where(sentemail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SentEmailClient) GetX(ctx context.Context, id int) *SentEmail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a SentEmail.
func (c *SentEmailClient) QueryProfile(se *SentEmail) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sentemail.Table, sentemail.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sentemail.ProfileTable, sentemail.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SentEmailClient) Hooks() []Hook {
	return c.hooks.SentEmail
}

// Interceptors returns the client interceptors.
func (c *SentEmailClient) Interceptors() []Interceptor {
	return c.inters.SentEmail
}

func (c *SentEmailClient) mutate(ctx context.Context, m *SentEmailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SentEmailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SentEmailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SentEmailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SentEmailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SentEmail mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a User.
func (c *UserClient) QueryOwner(u *User) *PasswordTokenQuery {
	query := (&PasswordTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(passwordtoken.Table, passwordtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.OwnerTable, user.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfile queries the profile edge of a User.
func (c *UserClient) QueryProfile(u *User) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.ProfileTable, user.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLastSeenAt queries the last_seen_at edge of a User.
func (c *UserClient) QueryLastSeenAt(u *User) *LastSeenOnlineQuery {
	query := (&LastSeenOnlineClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(lastseenonline.Table, lastseenonline.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LastSeenAtTable, user.LastSeenAtColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		EmailSubscription, EmailSubscriptionType, Emojis, FCMSubscriptions, FileStorage,
		Image, ImageSize, Invitation, LastSeenOnline, MonthlySubscription,
		Notification, NotificationPermission, NotificationTime, PasswordToken,
		PhoneVerificationCode, Profile, PwaPushSubscription, SentEmail, User []ent.Hook
	}
	inters struct {
		EmailSubscription, EmailSubscriptionType, Emojis, FCMSubscriptions, FileStorage,
		Image, ImageSize, Invitation, LastSeenOnline, MonthlySubscription,
		Notification, NotificationPermission, NotificationTime, PasswordToken,
		PhoneVerificationCode, Profile, PwaPushSubscription, SentEmail,
		User []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
