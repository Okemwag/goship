// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/mikestefanello/pagoda/ent/emailsubscription"
	"github.com/mikestefanello/pagoda/ent/emailsubscriptiontype"
	"github.com/mikestefanello/pagoda/ent/emojis"
	"github.com/mikestefanello/pagoda/ent/fcmsubscriptions"
	"github.com/mikestefanello/pagoda/ent/filestorage"
	"github.com/mikestefanello/pagoda/ent/image"
	"github.com/mikestefanello/pagoda/ent/imagesize"
	"github.com/mikestefanello/pagoda/ent/invitation"
	"github.com/mikestefanello/pagoda/ent/lastseenonline"
	"github.com/mikestefanello/pagoda/ent/monthlysubscription"
	"github.com/mikestefanello/pagoda/ent/notification"
	"github.com/mikestefanello/pagoda/ent/notificationpermission"
	"github.com/mikestefanello/pagoda/ent/notificationtime"
	"github.com/mikestefanello/pagoda/ent/passwordtoken"
	"github.com/mikestefanello/pagoda/ent/phoneverificationcode"
	"github.com/mikestefanello/pagoda/ent/predicate"
	"github.com/mikestefanello/pagoda/ent/profile"
	"github.com/mikestefanello/pagoda/ent/pwapushsubscription"
	"github.com/mikestefanello/pagoda/ent/sentemail"
	"github.com/mikestefanello/pagoda/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEmailSubscription      = "EmailSubscription"
	TypeEmailSubscriptionType  = "EmailSubscriptionType"
	TypeEmojis                 = "Emojis"
	TypeFCMSubscriptions       = "FCMSubscriptions"
	TypeFileStorage            = "FileStorage"
	TypeImage                  = "Image"
	TypeImageSize              = "ImageSize"
	TypeInvitation             = "Invitation"
	TypeLastSeenOnline         = "LastSeenOnline"
	TypeMonthlySubscription    = "MonthlySubscription"
	TypeNotification           = "Notification"
	TypeNotificationPermission = "NotificationPermission"
	TypeNotificationTime       = "NotificationTime"
	TypePasswordToken          = "PasswordToken"
	TypePhoneVerificationCode  = "PhoneVerificationCode"
	TypeProfile                = "Profile"
	TypePwaPushSubscription    = "PwaPushSubscription"
	TypeSentEmail              = "SentEmail"
	TypeUser                   = "User"
)

// EmailSubscriptionMutation represents an operation that mutates the EmailSubscription nodes in the graph.
type EmailSubscriptionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	email                *string
	verified             *bool
	confirmation_code    *string
	latitude             *float64
	addlatitude          *float64
	longitude            *float64
	addlongitude         *float64
	clearedFields        map[string]struct{}
	subscriptions        map[int]struct{}
	removedsubscriptions map[int]struct{}
	clearedsubscriptions bool
	done                 bool
	oldValue             func(context.Context) (*EmailSubscription, error)
	predicates           []predicate.EmailSubscription
}

var _ ent.Mutation = (*EmailSubscriptionMutation)(nil)

// emailsubscriptionOption allows management of the mutation configuration using functional options.
type emailsubscriptionOption func(*EmailSubscriptionMutation)

// newEmailSubscriptionMutation creates new mutation for the EmailSubscription entity.
func newEmailSubscriptionMutation(c config, op Op, opts ...emailsubscriptionOption) *EmailSubscriptionMutation {
	m := &EmailSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailSubscriptionID sets the ID field of the mutation.
func withEmailSubscriptionID(id int) emailsubscriptionOption {
	return func(m *EmailSubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailSubscription
		)
		m.oldValue = func(ctx context.Context) (*EmailSubscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailSubscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailSubscription sets the old EmailSubscription of the mutation.
func withEmailSubscription(node *EmailSubscription) emailsubscriptionOption {
	return func(m *EmailSubscriptionMutation) {
		m.oldValue = func(context.Context) (*EmailSubscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailSubscriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailSubscriptionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailSubscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailSubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailSubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailSubscription entity.
// If the EmailSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailSubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailSubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailSubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailSubscription entity.
// If the EmailSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailSubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *EmailSubscriptionMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmailSubscriptionMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the EmailSubscription entity.
// If the EmailSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSubscriptionMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *EmailSubscriptionMutation) ResetEmail() {
	m.email = nil
}

// SetVerified sets the "verified" field.
func (m *EmailSubscriptionMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *EmailSubscriptionMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the EmailSubscription entity.
// If the EmailSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSubscriptionMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *EmailSubscriptionMutation) ResetVerified() {
	m.verified = nil
}

// SetConfirmationCode sets the "confirmation_code" field.
func (m *EmailSubscriptionMutation) SetConfirmationCode(s string) {
	m.confirmation_code = &s
}

// ConfirmationCode returns the value of the "confirmation_code" field in the mutation.
func (m *EmailSubscriptionMutation) ConfirmationCode() (r string, exists bool) {
	v := m.confirmation_code
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmationCode returns the old "confirmation_code" field's value of the EmailSubscription entity.
// If the EmailSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSubscriptionMutation) OldConfirmationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmationCode: %w", err)
	}
	return oldValue.ConfirmationCode, nil
}

// ResetConfirmationCode resets all changes to the "confirmation_code" field.
func (m *EmailSubscriptionMutation) ResetConfirmationCode() {
	m.confirmation_code = nil
}

// SetLatitude sets the "latitude" field.
func (m *EmailSubscriptionMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *EmailSubscriptionMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the EmailSubscription entity.
// If the EmailSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSubscriptionMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *EmailSubscriptionMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *EmailSubscriptionMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *EmailSubscriptionMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[emailsubscription.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *EmailSubscriptionMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[emailsubscription.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *EmailSubscriptionMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, emailsubscription.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *EmailSubscriptionMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *EmailSubscriptionMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the EmailSubscription entity.
// If the EmailSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSubscriptionMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *EmailSubscriptionMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *EmailSubscriptionMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *EmailSubscriptionMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[emailsubscription.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *EmailSubscriptionMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[emailsubscription.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *EmailSubscriptionMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, emailsubscription.FieldLongitude)
}

// AddSubscriptionIDs adds the "subscriptions" edge to the EmailSubscriptionType entity by ids.
func (m *EmailSubscriptionMutation) AddSubscriptionIDs(ids ...int) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the EmailSubscriptionType entity.
func (m *EmailSubscriptionMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the EmailSubscriptionType entity was cleared.
func (m *EmailSubscriptionMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the EmailSubscriptionType entity by IDs.
func (m *EmailSubscriptionMutation) RemoveSubscriptionIDs(ids ...int) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the EmailSubscriptionType entity.
func (m *EmailSubscriptionMutation) RemovedSubscriptionsIDs() (ids []int) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *EmailSubscriptionMutation) SubscriptionsIDs() (ids []int) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *EmailSubscriptionMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// Where appends a list predicates to the EmailSubscriptionMutation builder.
func (m *EmailSubscriptionMutation) Where(ps ...predicate.EmailSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailSubscription).
func (m *EmailSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, emailsubscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailsubscription.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, emailsubscription.FieldEmail)
	}
	if m.verified != nil {
		fields = append(fields, emailsubscription.FieldVerified)
	}
	if m.confirmation_code != nil {
		fields = append(fields, emailsubscription.FieldConfirmationCode)
	}
	if m.latitude != nil {
		fields = append(fields, emailsubscription.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, emailsubscription.FieldLongitude)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailsubscription.FieldCreatedAt:
		return m.CreatedAt()
	case emailsubscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailsubscription.FieldEmail:
		return m.Email()
	case emailsubscription.FieldVerified:
		return m.Verified()
	case emailsubscription.FieldConfirmationCode:
		return m.ConfirmationCode()
	case emailsubscription.FieldLatitude:
		return m.Latitude()
	case emailsubscription.FieldLongitude:
		return m.Longitude()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailsubscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailsubscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailsubscription.FieldEmail:
		return m.OldEmail(ctx)
	case emailsubscription.FieldVerified:
		return m.OldVerified(ctx)
	case emailsubscription.FieldConfirmationCode:
		return m.OldConfirmationCode(ctx)
	case emailsubscription.FieldLatitude:
		return m.OldLatitude(ctx)
	case emailsubscription.FieldLongitude:
		return m.OldLongitude(ctx)
	}
	return nil, fmt.Errorf("unknown EmailSubscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailsubscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailsubscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailsubscription.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case emailsubscription.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case emailsubscription.FieldConfirmationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmationCode(v)
		return nil
	case emailsubscription.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case emailsubscription.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown EmailSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailSubscriptionMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, emailsubscription.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, emailsubscription.FieldLongitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case emailsubscription.FieldLatitude:
		return m.AddedLatitude()
	case emailsubscription.FieldLongitude:
		return m.AddedLongitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case emailsubscription.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case emailsubscription.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown EmailSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailSubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailsubscription.FieldLatitude) {
		fields = append(fields, emailsubscription.FieldLatitude)
	}
	if m.FieldCleared(emailsubscription.FieldLongitude) {
		fields = append(fields, emailsubscription.FieldLongitude)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailSubscriptionMutation) ClearField(name string) error {
	switch name {
	case emailsubscription.FieldLatitude:
		m.ClearLatitude()
		return nil
	case emailsubscription.FieldLongitude:
		m.ClearLongitude()
		return nil
	}
	return fmt.Errorf("unknown EmailSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailSubscriptionMutation) ResetField(name string) error {
	switch name {
	case emailsubscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailsubscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailsubscription.FieldEmail:
		m.ResetEmail()
		return nil
	case emailsubscription.FieldVerified:
		m.ResetVerified()
		return nil
	case emailsubscription.FieldConfirmationCode:
		m.ResetConfirmationCode()
		return nil
	case emailsubscription.FieldLatitude:
		m.ResetLatitude()
		return nil
	case emailsubscription.FieldLongitude:
		m.ResetLongitude()
		return nil
	}
	return fmt.Errorf("unknown EmailSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subscriptions != nil {
		edges = append(edges, emailsubscription.EdgeSubscriptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailsubscription.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubscriptions != nil {
		edges = append(edges, emailsubscription.EdgeSubscriptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case emailsubscription.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubscriptions {
		edges = append(edges, emailsubscription.EdgeSubscriptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case emailsubscription.EdgeSubscriptions:
		return m.clearedsubscriptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case emailsubscription.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	}
	return fmt.Errorf("unknown EmailSubscription edge %s", name)
}

// EmailSubscriptionTypeMutation represents an operation that mutates the EmailSubscriptionType nodes in the graph.
type EmailSubscriptionTypeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	name              *emailsubscriptiontype.Name
	active            *bool
	clearedFields     map[string]struct{}
	subscriber        map[int]struct{}
	removedsubscriber map[int]struct{}
	clearedsubscriber bool
	done              bool
	oldValue          func(context.Context) (*EmailSubscriptionType, error)
	predicates        []predicate.EmailSubscriptionType
}

var _ ent.Mutation = (*EmailSubscriptionTypeMutation)(nil)

// emailsubscriptiontypeOption allows management of the mutation configuration using functional options.
type emailsubscriptiontypeOption func(*EmailSubscriptionTypeMutation)

// newEmailSubscriptionTypeMutation creates new mutation for the EmailSubscriptionType entity.
func newEmailSubscriptionTypeMutation(c config, op Op, opts ...emailsubscriptiontypeOption) *EmailSubscriptionTypeMutation {
	m := &EmailSubscriptionTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailSubscriptionType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailSubscriptionTypeID sets the ID field of the mutation.
func withEmailSubscriptionTypeID(id int) emailsubscriptiontypeOption {
	return func(m *EmailSubscriptionTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailSubscriptionType
		)
		m.oldValue = func(ctx context.Context) (*EmailSubscriptionType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailSubscriptionType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailSubscriptionType sets the old EmailSubscriptionType of the mutation.
func withEmailSubscriptionType(node *EmailSubscriptionType) emailsubscriptiontypeOption {
	return func(m *EmailSubscriptionTypeMutation) {
		m.oldValue = func(context.Context) (*EmailSubscriptionType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailSubscriptionTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailSubscriptionTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailSubscriptionTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailSubscriptionTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailSubscriptionType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailSubscriptionTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailSubscriptionTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailSubscriptionType entity.
// If the EmailSubscriptionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSubscriptionTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailSubscriptionTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailSubscriptionTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailSubscriptionTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailSubscriptionType entity.
// If the EmailSubscriptionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSubscriptionTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailSubscriptionTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *EmailSubscriptionTypeMutation) SetName(e emailsubscriptiontype.Name) {
	m.name = &e
}

// Name returns the value of the "name" field in the mutation.
func (m *EmailSubscriptionTypeMutation) Name() (r emailsubscriptiontype.Name, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EmailSubscriptionType entity.
// If the EmailSubscriptionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSubscriptionTypeMutation) OldName(ctx context.Context) (v emailsubscriptiontype.Name, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmailSubscriptionTypeMutation) ResetName() {
	m.name = nil
}

// SetActive sets the "active" field.
func (m *EmailSubscriptionTypeMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *EmailSubscriptionTypeMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the EmailSubscriptionType entity.
// If the EmailSubscriptionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSubscriptionTypeMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *EmailSubscriptionTypeMutation) ResetActive() {
	m.active = nil
}

// AddSubscriberIDs adds the "subscriber" edge to the EmailSubscription entity by ids.
func (m *EmailSubscriptionTypeMutation) AddSubscriberIDs(ids ...int) {
	if m.subscriber == nil {
		m.subscriber = make(map[int]struct{})
	}
	for i := range ids {
		m.subscriber[ids[i]] = struct{}{}
	}
}

// ClearSubscriber clears the "subscriber" edge to the EmailSubscription entity.
func (m *EmailSubscriptionTypeMutation) ClearSubscriber() {
	m.clearedsubscriber = true
}

// SubscriberCleared reports if the "subscriber" edge to the EmailSubscription entity was cleared.
func (m *EmailSubscriptionTypeMutation) SubscriberCleared() bool {
	return m.clearedsubscriber
}

// RemoveSubscriberIDs removes the "subscriber" edge to the EmailSubscription entity by IDs.
func (m *EmailSubscriptionTypeMutation) RemoveSubscriberIDs(ids ...int) {
	if m.removedsubscriber == nil {
		m.removedsubscriber = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscriber, ids[i])
		m.removedsubscriber[ids[i]] = struct{}{}
	}
}

// RemovedSubscriber returns the removed IDs of the "subscriber" edge to the EmailSubscription entity.
func (m *EmailSubscriptionTypeMutation) RemovedSubscriberIDs() (ids []int) {
	for id := range m.removedsubscriber {
		ids = append(ids, id)
	}
	return
}

// SubscriberIDs returns the "subscriber" edge IDs in the mutation.
func (m *EmailSubscriptionTypeMutation) SubscriberIDs() (ids []int) {
	for id := range m.subscriber {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriber resets all changes to the "subscriber" edge.
func (m *EmailSubscriptionTypeMutation) ResetSubscriber() {
	m.subscriber = nil
	m.clearedsubscriber = false
	m.removedsubscriber = nil
}

// Where appends a list predicates to the EmailSubscriptionTypeMutation builder.
func (m *EmailSubscriptionTypeMutation) Where(ps ...predicate.EmailSubscriptionType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailSubscriptionTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailSubscriptionTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailSubscriptionType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailSubscriptionTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailSubscriptionTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailSubscriptionType).
func (m *EmailSubscriptionTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailSubscriptionTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, emailsubscriptiontype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailsubscriptiontype.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, emailsubscriptiontype.FieldName)
	}
	if m.active != nil {
		fields = append(fields, emailsubscriptiontype.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailSubscriptionTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailsubscriptiontype.FieldCreatedAt:
		return m.CreatedAt()
	case emailsubscriptiontype.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailsubscriptiontype.FieldName:
		return m.Name()
	case emailsubscriptiontype.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailSubscriptionTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailsubscriptiontype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailsubscriptiontype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailsubscriptiontype.FieldName:
		return m.OldName(ctx)
	case emailsubscriptiontype.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown EmailSubscriptionType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSubscriptionTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailsubscriptiontype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailsubscriptiontype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailsubscriptiontype.FieldName:
		v, ok := value.(emailsubscriptiontype.Name)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case emailsubscriptiontype.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown EmailSubscriptionType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailSubscriptionTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailSubscriptionTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSubscriptionTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailSubscriptionType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailSubscriptionTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailSubscriptionTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailSubscriptionTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EmailSubscriptionType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailSubscriptionTypeMutation) ResetField(name string) error {
	switch name {
	case emailsubscriptiontype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailsubscriptiontype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailsubscriptiontype.FieldName:
		m.ResetName()
		return nil
	case emailsubscriptiontype.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown EmailSubscriptionType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailSubscriptionTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subscriber != nil {
		edges = append(edges, emailsubscriptiontype.EdgeSubscriber)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailSubscriptionTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailsubscriptiontype.EdgeSubscriber:
		ids := make([]ent.Value, 0, len(m.subscriber))
		for id := range m.subscriber {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailSubscriptionTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubscriber != nil {
		edges = append(edges, emailsubscriptiontype.EdgeSubscriber)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailSubscriptionTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case emailsubscriptiontype.EdgeSubscriber:
		ids := make([]ent.Value, 0, len(m.removedsubscriber))
		for id := range m.removedsubscriber {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailSubscriptionTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubscriber {
		edges = append(edges, emailsubscriptiontype.EdgeSubscriber)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailSubscriptionTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case emailsubscriptiontype.EdgeSubscriber:
		return m.clearedsubscriber
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailSubscriptionTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailSubscriptionType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailSubscriptionTypeMutation) ResetEdge(name string) error {
	switch name {
	case emailsubscriptiontype.EdgeSubscriber:
		m.ResetSubscriber()
		return nil
	}
	return fmt.Errorf("unknown EmailSubscriptionType edge %s", name)
}

// EmojisMutation represents an operation that mutates the Emojis nodes in the graph.
type EmojisMutation struct {
	config
	op            Op
	typ           string
	id            *int
	unified_code  *string
	shortcode     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Emojis, error)
	predicates    []predicate.Emojis
}

var _ ent.Mutation = (*EmojisMutation)(nil)

// emojisOption allows management of the mutation configuration using functional options.
type emojisOption func(*EmojisMutation)

// newEmojisMutation creates new mutation for the Emojis entity.
func newEmojisMutation(c config, op Op, opts ...emojisOption) *EmojisMutation {
	m := &EmojisMutation{
		config:        c,
		op:            op,
		typ:           TypeEmojis,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmojisID sets the ID field of the mutation.
func withEmojisID(id int) emojisOption {
	return func(m *EmojisMutation) {
		var (
			err   error
			once  sync.Once
			value *Emojis
		)
		m.oldValue = func(ctx context.Context) (*Emojis, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Emojis.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmojis sets the old Emojis of the mutation.
func withEmojis(node *Emojis) emojisOption {
	return func(m *EmojisMutation) {
		m.oldValue = func(context.Context) (*Emojis, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmojisMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmojisMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmojisMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmojisMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Emojis.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUnifiedCode sets the "unified_code" field.
func (m *EmojisMutation) SetUnifiedCode(s string) {
	m.unified_code = &s
}

// UnifiedCode returns the value of the "unified_code" field in the mutation.
func (m *EmojisMutation) UnifiedCode() (r string, exists bool) {
	v := m.unified_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUnifiedCode returns the old "unified_code" field's value of the Emojis entity.
// If the Emojis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmojisMutation) OldUnifiedCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnifiedCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnifiedCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnifiedCode: %w", err)
	}
	return oldValue.UnifiedCode, nil
}

// ResetUnifiedCode resets all changes to the "unified_code" field.
func (m *EmojisMutation) ResetUnifiedCode() {
	m.unified_code = nil
}

// SetShortcode sets the "shortcode" field.
func (m *EmojisMutation) SetShortcode(s string) {
	m.shortcode = &s
}

// Shortcode returns the value of the "shortcode" field in the mutation.
func (m *EmojisMutation) Shortcode() (r string, exists bool) {
	v := m.shortcode
	if v == nil {
		return
	}
	return *v, true
}

// OldShortcode returns the old "shortcode" field's value of the Emojis entity.
// If the Emojis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmojisMutation) OldShortcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortcode: %w", err)
	}
	return oldValue.Shortcode, nil
}

// ResetShortcode resets all changes to the "shortcode" field.
func (m *EmojisMutation) ResetShortcode() {
	m.shortcode = nil
}

// Where appends a list predicates to the EmojisMutation builder.
func (m *EmojisMutation) Where(ps ...predicate.Emojis) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmojisMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmojisMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Emojis, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmojisMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmojisMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Emojis).
func (m *EmojisMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmojisMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.unified_code != nil {
		fields = append(fields, emojis.FieldUnifiedCode)
	}
	if m.shortcode != nil {
		fields = append(fields, emojis.FieldShortcode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmojisMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emojis.FieldUnifiedCode:
		return m.UnifiedCode()
	case emojis.FieldShortcode:
		return m.Shortcode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmojisMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emojis.FieldUnifiedCode:
		return m.OldUnifiedCode(ctx)
	case emojis.FieldShortcode:
		return m.OldShortcode(ctx)
	}
	return nil, fmt.Errorf("unknown Emojis field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmojisMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emojis.FieldUnifiedCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnifiedCode(v)
		return nil
	case emojis.FieldShortcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortcode(v)
		return nil
	}
	return fmt.Errorf("unknown Emojis field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmojisMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmojisMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmojisMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Emojis numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmojisMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmojisMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmojisMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Emojis nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmojisMutation) ResetField(name string) error {
	switch name {
	case emojis.FieldUnifiedCode:
		m.ResetUnifiedCode()
		return nil
	case emojis.FieldShortcode:
		m.ResetShortcode()
		return nil
	}
	return fmt.Errorf("unknown Emojis field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmojisMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmojisMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmojisMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmojisMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmojisMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmojisMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmojisMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Emojis unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmojisMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Emojis edge %s", name)
}

// FCMSubscriptionsMutation represents an operation that mutates the FCMSubscriptions nodes in the graph.
type FCMSubscriptionsMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	token          *string
	clearedFields  map[string]struct{}
	profile        *int
	clearedprofile bool
	done           bool
	oldValue       func(context.Context) (*FCMSubscriptions, error)
	predicates     []predicate.FCMSubscriptions
}

var _ ent.Mutation = (*FCMSubscriptionsMutation)(nil)

// fcmsubscriptionsOption allows management of the mutation configuration using functional options.
type fcmsubscriptionsOption func(*FCMSubscriptionsMutation)

// newFCMSubscriptionsMutation creates new mutation for the FCMSubscriptions entity.
func newFCMSubscriptionsMutation(c config, op Op, opts ...fcmsubscriptionsOption) *FCMSubscriptionsMutation {
	m := &FCMSubscriptionsMutation{
		config:        c,
		op:            op,
		typ:           TypeFCMSubscriptions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFCMSubscriptionsID sets the ID field of the mutation.
func withFCMSubscriptionsID(id int) fcmsubscriptionsOption {
	return func(m *FCMSubscriptionsMutation) {
		var (
			err   error
			once  sync.Once
			value *FCMSubscriptions
		)
		m.oldValue = func(ctx context.Context) (*FCMSubscriptions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FCMSubscriptions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFCMSubscriptions sets the old FCMSubscriptions of the mutation.
func withFCMSubscriptions(node *FCMSubscriptions) fcmsubscriptionsOption {
	return func(m *FCMSubscriptionsMutation) {
		m.oldValue = func(context.Context) (*FCMSubscriptions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FCMSubscriptionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FCMSubscriptionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FCMSubscriptionsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FCMSubscriptionsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FCMSubscriptions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FCMSubscriptionsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FCMSubscriptionsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FCMSubscriptions entity.
// If the FCMSubscriptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCMSubscriptionsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FCMSubscriptionsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FCMSubscriptionsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FCMSubscriptionsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FCMSubscriptions entity.
// If the FCMSubscriptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCMSubscriptionsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FCMSubscriptionsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetToken sets the "token" field.
func (m *FCMSubscriptionsMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *FCMSubscriptionsMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the FCMSubscriptions entity.
// If the FCMSubscriptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCMSubscriptionsMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *FCMSubscriptionsMutation) ResetToken() {
	m.token = nil
}

// SetProfileID sets the "profile_id" field.
func (m *FCMSubscriptionsMutation) SetProfileID(i int) {
	m.profile = &i
}

// ProfileID returns the value of the "profile_id" field in the mutation.
func (m *FCMSubscriptionsMutation) ProfileID() (r int, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileID returns the old "profile_id" field's value of the FCMSubscriptions entity.
// If the FCMSubscriptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FCMSubscriptionsMutation) OldProfileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileID: %w", err)
	}
	return oldValue.ProfileID, nil
}

// ResetProfileID resets all changes to the "profile_id" field.
func (m *FCMSubscriptionsMutation) ResetProfileID() {
	m.profile = nil
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *FCMSubscriptionsMutation) ClearProfile() {
	m.clearedprofile = true
	m.clearedFields[fcmsubscriptions.FieldProfileID] = struct{}{}
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *FCMSubscriptionsMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *FCMSubscriptionsMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *FCMSubscriptionsMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the FCMSubscriptionsMutation builder.
func (m *FCMSubscriptionsMutation) Where(ps ...predicate.FCMSubscriptions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FCMSubscriptionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FCMSubscriptionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FCMSubscriptions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FCMSubscriptionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FCMSubscriptionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FCMSubscriptions).
func (m *FCMSubscriptionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FCMSubscriptionsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, fcmsubscriptions.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fcmsubscriptions.FieldUpdatedAt)
	}
	if m.token != nil {
		fields = append(fields, fcmsubscriptions.FieldToken)
	}
	if m.profile != nil {
		fields = append(fields, fcmsubscriptions.FieldProfileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FCMSubscriptionsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fcmsubscriptions.FieldCreatedAt:
		return m.CreatedAt()
	case fcmsubscriptions.FieldUpdatedAt:
		return m.UpdatedAt()
	case fcmsubscriptions.FieldToken:
		return m.Token()
	case fcmsubscriptions.FieldProfileID:
		return m.ProfileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FCMSubscriptionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fcmsubscriptions.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fcmsubscriptions.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fcmsubscriptions.FieldToken:
		return m.OldToken(ctx)
	case fcmsubscriptions.FieldProfileID:
		return m.OldProfileID(ctx)
	}
	return nil, fmt.Errorf("unknown FCMSubscriptions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FCMSubscriptionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fcmsubscriptions.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fcmsubscriptions.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fcmsubscriptions.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case fcmsubscriptions.FieldProfileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileID(v)
		return nil
	}
	return fmt.Errorf("unknown FCMSubscriptions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FCMSubscriptionsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FCMSubscriptionsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FCMSubscriptionsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FCMSubscriptions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FCMSubscriptionsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FCMSubscriptionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FCMSubscriptionsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FCMSubscriptions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FCMSubscriptionsMutation) ResetField(name string) error {
	switch name {
	case fcmsubscriptions.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fcmsubscriptions.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fcmsubscriptions.FieldToken:
		m.ResetToken()
		return nil
	case fcmsubscriptions.FieldProfileID:
		m.ResetProfileID()
		return nil
	}
	return fmt.Errorf("unknown FCMSubscriptions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FCMSubscriptionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.profile != nil {
		edges = append(edges, fcmsubscriptions.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FCMSubscriptionsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fcmsubscriptions.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FCMSubscriptionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FCMSubscriptionsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FCMSubscriptionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprofile {
		edges = append(edges, fcmsubscriptions.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FCMSubscriptionsMutation) EdgeCleared(name string) bool {
	switch name {
	case fcmsubscriptions.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FCMSubscriptionsMutation) ClearEdge(name string) error {
	switch name {
	case fcmsubscriptions.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown FCMSubscriptions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FCMSubscriptionsMutation) ResetEdge(name string) error {
	switch name {
	case fcmsubscriptions.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown FCMSubscriptions edge %s", name)
}

// FileStorageMutation represents an operation that mutates the FileStorage nodes in the graph.
type FileStorageMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	bucket_name        *string
	object_key         *string
	original_file_name *string
	file_size          *int64
	addfile_size       *int64
	content_type       *string
	file_hash          *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*FileStorage, error)
	predicates         []predicate.FileStorage
}

var _ ent.Mutation = (*FileStorageMutation)(nil)

// filestorageOption allows management of the mutation configuration using functional options.
type filestorageOption func(*FileStorageMutation)

// newFileStorageMutation creates new mutation for the FileStorage entity.
func newFileStorageMutation(c config, op Op, opts ...filestorageOption) *FileStorageMutation {
	m := &FileStorageMutation{
		config:        c,
		op:            op,
		typ:           TypeFileStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileStorageID sets the ID field of the mutation.
func withFileStorageID(id int) filestorageOption {
	return func(m *FileStorageMutation) {
		var (
			err   error
			once  sync.Once
			value *FileStorage
		)
		m.oldValue = func(ctx context.Context) (*FileStorage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileStorage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileStorage sets the old FileStorage of the mutation.
func withFileStorage(node *FileStorage) filestorageOption {
	return func(m *FileStorageMutation) {
		m.oldValue = func(context.Context) (*FileStorage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileStorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileStorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileStorageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileStorageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileStorage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileStorageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileStorageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FileStorage entity.
// If the FileStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileStorageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileStorageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileStorageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileStorageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FileStorage entity.
// If the FileStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileStorageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileStorageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBucketName sets the "bucket_name" field.
func (m *FileStorageMutation) SetBucketName(s string) {
	m.bucket_name = &s
}

// BucketName returns the value of the "bucket_name" field in the mutation.
func (m *FileStorageMutation) BucketName() (r string, exists bool) {
	v := m.bucket_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketName returns the old "bucket_name" field's value of the FileStorage entity.
// If the FileStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileStorageMutation) OldBucketName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketName: %w", err)
	}
	return oldValue.BucketName, nil
}

// ResetBucketName resets all changes to the "bucket_name" field.
func (m *FileStorageMutation) ResetBucketName() {
	m.bucket_name = nil
}

// SetObjectKey sets the "object_key" field.
func (m *FileStorageMutation) SetObjectKey(s string) {
	m.object_key = &s
}

// ObjectKey returns the value of the "object_key" field in the mutation.
func (m *FileStorageMutation) ObjectKey() (r string, exists bool) {
	v := m.object_key
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectKey returns the old "object_key" field's value of the FileStorage entity.
// If the FileStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileStorageMutation) OldObjectKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectKey: %w", err)
	}
	return oldValue.ObjectKey, nil
}

// ResetObjectKey resets all changes to the "object_key" field.
func (m *FileStorageMutation) ResetObjectKey() {
	m.object_key = nil
}

// SetOriginalFileName sets the "original_file_name" field.
func (m *FileStorageMutation) SetOriginalFileName(s string) {
	m.original_file_name = &s
}

// OriginalFileName returns the value of the "original_file_name" field in the mutation.
func (m *FileStorageMutation) OriginalFileName() (r string, exists bool) {
	v := m.original_file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalFileName returns the old "original_file_name" field's value of the FileStorage entity.
// If the FileStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileStorageMutation) OldOriginalFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalFileName: %w", err)
	}
	return oldValue.OriginalFileName, nil
}

// ClearOriginalFileName clears the value of the "original_file_name" field.
func (m *FileStorageMutation) ClearOriginalFileName() {
	m.original_file_name = nil
	m.clearedFields[filestorage.FieldOriginalFileName] = struct{}{}
}

// OriginalFileNameCleared returns if the "original_file_name" field was cleared in this mutation.
func (m *FileStorageMutation) OriginalFileNameCleared() bool {
	_, ok := m.clearedFields[filestorage.FieldOriginalFileName]
	return ok
}

// ResetOriginalFileName resets all changes to the "original_file_name" field.
func (m *FileStorageMutation) ResetOriginalFileName() {
	m.original_file_name = nil
	delete(m.clearedFields, filestorage.FieldOriginalFileName)
}

// SetFileSize sets the "file_size" field.
func (m *FileStorageMutation) SetFileSize(i int64) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *FileStorageMutation) FileSize() (r int64, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the FileStorage entity.
// If the FileStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileStorageMutation) OldFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *FileStorageMutation) AddFileSize(i int64) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *FileStorageMutation) AddedFileSize() (r int64, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileSize clears the value of the "file_size" field.
func (m *FileStorageMutation) ClearFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	m.clearedFields[filestorage.FieldFileSize] = struct{}{}
}

// FileSizeCleared returns if the "file_size" field was cleared in this mutation.
func (m *FileStorageMutation) FileSizeCleared() bool {
	_, ok := m.clearedFields[filestorage.FieldFileSize]
	return ok
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *FileStorageMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	delete(m.clearedFields, filestorage.FieldFileSize)
}

// SetContentType sets the "content_type" field.
func (m *FileStorageMutation) SetContentType(s string) {
	m.content_type = &s
}

// ContentType returns the value of the "content_type" field in the mutation.
func (m *FileStorageMutation) ContentType() (r string, exists bool) {
	v := m.content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old "content_type" field's value of the FileStorage entity.
// If the FileStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileStorageMutation) OldContentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// ClearContentType clears the value of the "content_type" field.
func (m *FileStorageMutation) ClearContentType() {
	m.content_type = nil
	m.clearedFields[filestorage.FieldContentType] = struct{}{}
}

// ContentTypeCleared returns if the "content_type" field was cleared in this mutation.
func (m *FileStorageMutation) ContentTypeCleared() bool {
	_, ok := m.clearedFields[filestorage.FieldContentType]
	return ok
}

// ResetContentType resets all changes to the "content_type" field.
func (m *FileStorageMutation) ResetContentType() {
	m.content_type = nil
	delete(m.clearedFields, filestorage.FieldContentType)
}

// SetFileHash sets the "file_hash" field.
func (m *FileStorageMutation) SetFileHash(s string) {
	m.file_hash = &s
}

// FileHash returns the value of the "file_hash" field in the mutation.
func (m *FileStorageMutation) FileHash() (r string, exists bool) {
	v := m.file_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldFileHash returns the old "file_hash" field's value of the FileStorage entity.
// If the FileStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileStorageMutation) OldFileHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileHash: %w", err)
	}
	return oldValue.FileHash, nil
}

// ClearFileHash clears the value of the "file_hash" field.
func (m *FileStorageMutation) ClearFileHash() {
	m.file_hash = nil
	m.clearedFields[filestorage.FieldFileHash] = struct{}{}
}

// FileHashCleared returns if the "file_hash" field was cleared in this mutation.
func (m *FileStorageMutation) FileHashCleared() bool {
	_, ok := m.clearedFields[filestorage.FieldFileHash]
	return ok
}

// ResetFileHash resets all changes to the "file_hash" field.
func (m *FileStorageMutation) ResetFileHash() {
	m.file_hash = nil
	delete(m.clearedFields, filestorage.FieldFileHash)
}

// Where appends a list predicates to the FileStorageMutation builder.
func (m *FileStorageMutation) Where(ps ...predicate.FileStorage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileStorageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileStorageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileStorage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileStorageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileStorageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileStorage).
func (m *FileStorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileStorageMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, filestorage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, filestorage.FieldUpdatedAt)
	}
	if m.bucket_name != nil {
		fields = append(fields, filestorage.FieldBucketName)
	}
	if m.object_key != nil {
		fields = append(fields, filestorage.FieldObjectKey)
	}
	if m.original_file_name != nil {
		fields = append(fields, filestorage.FieldOriginalFileName)
	}
	if m.file_size != nil {
		fields = append(fields, filestorage.FieldFileSize)
	}
	if m.content_type != nil {
		fields = append(fields, filestorage.FieldContentType)
	}
	if m.file_hash != nil {
		fields = append(fields, filestorage.FieldFileHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileStorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filestorage.FieldCreatedAt:
		return m.CreatedAt()
	case filestorage.FieldUpdatedAt:
		return m.UpdatedAt()
	case filestorage.FieldBucketName:
		return m.BucketName()
	case filestorage.FieldObjectKey:
		return m.ObjectKey()
	case filestorage.FieldOriginalFileName:
		return m.OriginalFileName()
	case filestorage.FieldFileSize:
		return m.FileSize()
	case filestorage.FieldContentType:
		return m.ContentType()
	case filestorage.FieldFileHash:
		return m.FileHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileStorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filestorage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case filestorage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case filestorage.FieldBucketName:
		return m.OldBucketName(ctx)
	case filestorage.FieldObjectKey:
		return m.OldObjectKey(ctx)
	case filestorage.FieldOriginalFileName:
		return m.OldOriginalFileName(ctx)
	case filestorage.FieldFileSize:
		return m.OldFileSize(ctx)
	case filestorage.FieldContentType:
		return m.OldContentType(ctx)
	case filestorage.FieldFileHash:
		return m.OldFileHash(ctx)
	}
	return nil, fmt.Errorf("unknown FileStorage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileStorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filestorage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case filestorage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case filestorage.FieldBucketName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketName(v)
		return nil
	case filestorage.FieldObjectKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectKey(v)
		return nil
	case filestorage.FieldOriginalFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalFileName(v)
		return nil
	case filestorage.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case filestorage.FieldContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	case filestorage.FieldFileHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileHash(v)
		return nil
	}
	return fmt.Errorf("unknown FileStorage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileStorageMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, filestorage.FieldFileSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileStorageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case filestorage.FieldFileSize:
		return m.AddedFileSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileStorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case filestorage.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	}
	return fmt.Errorf("unknown FileStorage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileStorageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(filestorage.FieldOriginalFileName) {
		fields = append(fields, filestorage.FieldOriginalFileName)
	}
	if m.FieldCleared(filestorage.FieldFileSize) {
		fields = append(fields, filestorage.FieldFileSize)
	}
	if m.FieldCleared(filestorage.FieldContentType) {
		fields = append(fields, filestorage.FieldContentType)
	}
	if m.FieldCleared(filestorage.FieldFileHash) {
		fields = append(fields, filestorage.FieldFileHash)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileStorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileStorageMutation) ClearField(name string) error {
	switch name {
	case filestorage.FieldOriginalFileName:
		m.ClearOriginalFileName()
		return nil
	case filestorage.FieldFileSize:
		m.ClearFileSize()
		return nil
	case filestorage.FieldContentType:
		m.ClearContentType()
		return nil
	case filestorage.FieldFileHash:
		m.ClearFileHash()
		return nil
	}
	return fmt.Errorf("unknown FileStorage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileStorageMutation) ResetField(name string) error {
	switch name {
	case filestorage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case filestorage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case filestorage.FieldBucketName:
		m.ResetBucketName()
		return nil
	case filestorage.FieldObjectKey:
		m.ResetObjectKey()
		return nil
	case filestorage.FieldOriginalFileName:
		m.ResetOriginalFileName()
		return nil
	case filestorage.FieldFileSize:
		m.ResetFileSize()
		return nil
	case filestorage.FieldContentType:
		m.ResetContentType()
		return nil
	case filestorage.FieldFileHash:
		m.ResetFileHash()
		return nil
	}
	return fmt.Errorf("unknown FileStorage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileStorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileStorageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileStorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileStorageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileStorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileStorageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileStorageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FileStorage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileStorageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FileStorage edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	_type         *image.Type
	clearedFields map[string]struct{}
	sizes         map[int]struct{}
	removedsizes  map[int]struct{}
	clearedsizes  bool
	done          bool
	oldValue      func(context.Context) (*Image, error)
	predicates    []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id int) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *ImageMutation) SetType(i image.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *ImageMutation) GetType() (r image.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldType(ctx context.Context) (v image.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ImageMutation) ResetType() {
	m._type = nil
}

// AddSizeIDs adds the "sizes" edge to the ImageSize entity by ids.
func (m *ImageMutation) AddSizeIDs(ids ...int) {
	if m.sizes == nil {
		m.sizes = make(map[int]struct{})
	}
	for i := range ids {
		m.sizes[ids[i]] = struct{}{}
	}
}

// ClearSizes clears the "sizes" edge to the ImageSize entity.
func (m *ImageMutation) ClearSizes() {
	m.clearedsizes = true
}

// SizesCleared reports if the "sizes" edge to the ImageSize entity was cleared.
func (m *ImageMutation) SizesCleared() bool {
	return m.clearedsizes
}

// RemoveSizeIDs removes the "sizes" edge to the ImageSize entity by IDs.
func (m *ImageMutation) RemoveSizeIDs(ids ...int) {
	if m.removedsizes == nil {
		m.removedsizes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sizes, ids[i])
		m.removedsizes[ids[i]] = struct{}{}
	}
}

// RemovedSizes returns the removed IDs of the "sizes" edge to the ImageSize entity.
func (m *ImageMutation) RemovedSizesIDs() (ids []int) {
	for id := range m.removedsizes {
		ids = append(ids, id)
	}
	return
}

// SizesIDs returns the "sizes" edge IDs in the mutation.
func (m *ImageMutation) SizesIDs() (ids []int) {
	for id := range m.sizes {
		ids = append(ids, id)
	}
	return
}

// ResetSizes resets all changes to the "sizes" edge.
func (m *ImageMutation) ResetSizes() {
	m.sizes = nil
	m.clearedsizes = false
	m.removedsizes = nil
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Image, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, image.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, image.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, image.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldCreatedAt:
		return m.CreatedAt()
	case image.FieldUpdatedAt:
		return m.UpdatedAt()
	case image.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case image.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case image.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case image.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case image.FieldType:
		v, ok := value.(image.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case image.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case image.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sizes != nil {
		edges = append(edges, image.EdgeSizes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeSizes:
		ids := make([]ent.Value, 0, len(m.sizes))
		for id := range m.sizes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsizes != nil {
		edges = append(edges, image.EdgeSizes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeSizes:
		ids := make([]ent.Value, 0, len(m.removedsizes))
		for id := range m.removedsizes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsizes {
		edges = append(edges, image.EdgeSizes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	switch name {
	case image.EdgeSizes:
		return m.clearedsizes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	switch name {
	case image.EdgeSizes:
		m.ResetSizes()
		return nil
	}
	return fmt.Errorf("unknown Image edge %s", name)
}

// ImageSizeMutation represents an operation that mutates the ImageSize nodes in the graph.
type ImageSizeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	size          *imagesize.Size
	width         *int
	addwidth      *int
	height        *int
	addheight     *int
	clearedFields map[string]struct{}
	file          *int
	clearedfile   bool
	image         *int
	clearedimage  bool
	done          bool
	oldValue      func(context.Context) (*ImageSize, error)
	predicates    []predicate.ImageSize
}

var _ ent.Mutation = (*ImageSizeMutation)(nil)

// imagesizeOption allows management of the mutation configuration using functional options.
type imagesizeOption func(*ImageSizeMutation)

// newImageSizeMutation creates new mutation for the ImageSize entity.
func newImageSizeMutation(c config, op Op, opts ...imagesizeOption) *ImageSizeMutation {
	m := &ImageSizeMutation{
		config:        c,
		op:            op,
		typ:           TypeImageSize,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageSizeID sets the ID field of the mutation.
func withImageSizeID(id int) imagesizeOption {
	return func(m *ImageSizeMutation) {
		var (
			err   error
			once  sync.Once
			value *ImageSize
		)
		m.oldValue = func(ctx context.Context) (*ImageSize, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImageSize.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImageSize sets the old ImageSize of the mutation.
func withImageSize(node *ImageSize) imagesizeOption {
	return func(m *ImageSizeMutation) {
		m.oldValue = func(context.Context) (*ImageSize, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageSizeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageSizeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageSizeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageSizeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImageSize.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ImageSizeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImageSizeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ImageSize entity.
// If the ImageSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageSizeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImageSizeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImageSizeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImageSizeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ImageSize entity.
// If the ImageSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageSizeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImageSizeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSize sets the "size" field.
func (m *ImageSizeMutation) SetSize(i imagesize.Size) {
	m.size = &i
}

// Size returns the value of the "size" field in the mutation.
func (m *ImageSizeMutation) Size() (r imagesize.Size, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the ImageSize entity.
// If the ImageSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageSizeMutation) OldSize(ctx context.Context) (v imagesize.Size, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ResetSize resets all changes to the "size" field.
func (m *ImageSizeMutation) ResetSize() {
	m.size = nil
}

// SetWidth sets the "width" field.
func (m *ImageSizeMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *ImageSizeMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the ImageSize entity.
// If the ImageSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageSizeMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *ImageSizeMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *ImageSizeMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *ImageSizeMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *ImageSizeMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *ImageSizeMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the ImageSize entity.
// If the ImageSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageSizeMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *ImageSizeMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *ImageSizeMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *ImageSizeMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetFileID sets the "file" edge to the FileStorage entity by id.
func (m *ImageSizeMutation) SetFileID(id int) {
	m.file = &id
}

// ClearFile clears the "file" edge to the FileStorage entity.
func (m *ImageSizeMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the FileStorage entity was cleared.
func (m *ImageSizeMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *ImageSizeMutation) FileID() (id int, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *ImageSizeMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *ImageSizeMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// SetImageID sets the "image" edge to the Image entity by id.
func (m *ImageSizeMutation) SetImageID(id int) {
	m.image = &id
}

// ClearImage clears the "image" edge to the Image entity.
func (m *ImageSizeMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *ImageSizeMutation) ImageCleared() bool {
	return m.clearedimage
}

// ImageID returns the "image" edge ID in the mutation.
func (m *ImageSizeMutation) ImageID() (id int, exists bool) {
	if m.image != nil {
		return *m.image, true
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageID instead. It exists only for internal usage by the builders.
func (m *ImageSizeMutation) ImageIDs() (ids []int) {
	if id := m.image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *ImageSizeMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
}

// Where appends a list predicates to the ImageSizeMutation builder.
func (m *ImageSizeMutation) Where(ps ...predicate.ImageSize) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageSizeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageSizeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ImageSize, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageSizeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageSizeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ImageSize).
func (m *ImageSizeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageSizeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, imagesize.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, imagesize.FieldUpdatedAt)
	}
	if m.size != nil {
		fields = append(fields, imagesize.FieldSize)
	}
	if m.width != nil {
		fields = append(fields, imagesize.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, imagesize.FieldHeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageSizeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case imagesize.FieldCreatedAt:
		return m.CreatedAt()
	case imagesize.FieldUpdatedAt:
		return m.UpdatedAt()
	case imagesize.FieldSize:
		return m.Size()
	case imagesize.FieldWidth:
		return m.Width()
	case imagesize.FieldHeight:
		return m.Height()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageSizeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case imagesize.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case imagesize.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case imagesize.FieldSize:
		return m.OldSize(ctx)
	case imagesize.FieldWidth:
		return m.OldWidth(ctx)
	case imagesize.FieldHeight:
		return m.OldHeight(ctx)
	}
	return nil, fmt.Errorf("unknown ImageSize field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageSizeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case imagesize.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case imagesize.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case imagesize.FieldSize:
		v, ok := value.(imagesize.Size)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case imagesize.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case imagesize.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	}
	return fmt.Errorf("unknown ImageSize field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageSizeMutation) AddedFields() []string {
	var fields []string
	if m.addwidth != nil {
		fields = append(fields, imagesize.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, imagesize.FieldHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageSizeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case imagesize.FieldWidth:
		return m.AddedWidth()
	case imagesize.FieldHeight:
		return m.AddedHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageSizeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case imagesize.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case imagesize.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	}
	return fmt.Errorf("unknown ImageSize numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageSizeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageSizeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageSizeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ImageSize nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageSizeMutation) ResetField(name string) error {
	switch name {
	case imagesize.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case imagesize.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case imagesize.FieldSize:
		m.ResetSize()
		return nil
	case imagesize.FieldWidth:
		m.ResetWidth()
		return nil
	case imagesize.FieldHeight:
		m.ResetHeight()
		return nil
	}
	return fmt.Errorf("unknown ImageSize field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageSizeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.file != nil {
		edges = append(edges, imagesize.EdgeFile)
	}
	if m.image != nil {
		edges = append(edges, imagesize.EdgeImage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageSizeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case imagesize.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case imagesize.EdgeImage:
		if id := m.image; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageSizeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageSizeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageSizeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfile {
		edges = append(edges, imagesize.EdgeFile)
	}
	if m.clearedimage {
		edges = append(edges, imagesize.EdgeImage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageSizeMutation) EdgeCleared(name string) bool {
	switch name {
	case imagesize.EdgeFile:
		return m.clearedfile
	case imagesize.EdgeImage:
		return m.clearedimage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageSizeMutation) ClearEdge(name string) error {
	switch name {
	case imagesize.EdgeFile:
		m.ClearFile()
		return nil
	case imagesize.EdgeImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown ImageSize unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageSizeMutation) ResetEdge(name string) error {
	switch name {
	case imagesize.EdgeFile:
		m.ResetFile()
		return nil
	case imagesize.EdgeImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown ImageSize edge %s", name)
}

// InvitationMutation represents an operation that mutates the Invitation nodes in the graph.
type InvitationMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	invitee_name      *string
	confirmation_code *string
	clearedFields     map[string]struct{}
	inviter           *int
	clearedinviter    bool
	done              bool
	oldValue          func(context.Context) (*Invitation, error)
	predicates        []predicate.Invitation
}

var _ ent.Mutation = (*InvitationMutation)(nil)

// invitationOption allows management of the mutation configuration using functional options.
type invitationOption func(*InvitationMutation)

// newInvitationMutation creates new mutation for the Invitation entity.
func newInvitationMutation(c config, op Op, opts ...invitationOption) *InvitationMutation {
	m := &InvitationMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationID sets the ID field of the mutation.
func withInvitationID(id int) invitationOption {
	return func(m *InvitationMutation) {
		var (
			err   error
			once  sync.Once
			value *Invitation
		)
		m.oldValue = func(ctx context.Context) (*Invitation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invitation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitation sets the old Invitation of the mutation.
func withInvitation(node *Invitation) invitationOption {
	return func(m *InvitationMutation) {
		m.oldValue = func(context.Context) (*Invitation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invitation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvitationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvitationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvitationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetInviteeName sets the "invitee_name" field.
func (m *InvitationMutation) SetInviteeName(s string) {
	m.invitee_name = &s
}

// InviteeName returns the value of the "invitee_name" field in the mutation.
func (m *InvitationMutation) InviteeName() (r string, exists bool) {
	v := m.invitee_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteeName returns the old "invitee_name" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldInviteeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteeName: %w", err)
	}
	return oldValue.InviteeName, nil
}

// ResetInviteeName resets all changes to the "invitee_name" field.
func (m *InvitationMutation) ResetInviteeName() {
	m.invitee_name = nil
}

// SetConfirmationCode sets the "confirmation_code" field.
func (m *InvitationMutation) SetConfirmationCode(s string) {
	m.confirmation_code = &s
}

// ConfirmationCode returns the value of the "confirmation_code" field in the mutation.
func (m *InvitationMutation) ConfirmationCode() (r string, exists bool) {
	v := m.confirmation_code
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmationCode returns the old "confirmation_code" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldConfirmationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmationCode: %w", err)
	}
	return oldValue.ConfirmationCode, nil
}

// ResetConfirmationCode resets all changes to the "confirmation_code" field.
func (m *InvitationMutation) ResetConfirmationCode() {
	m.confirmation_code = nil
}

// SetInviterID sets the "inviter" edge to the Profile entity by id.
func (m *InvitationMutation) SetInviterID(id int) {
	m.inviter = &id
}

// ClearInviter clears the "inviter" edge to the Profile entity.
func (m *InvitationMutation) ClearInviter() {
	m.clearedinviter = true
}

// InviterCleared reports if the "inviter" edge to the Profile entity was cleared.
func (m *InvitationMutation) InviterCleared() bool {
	return m.clearedinviter
}

// InviterID returns the "inviter" edge ID in the mutation.
func (m *InvitationMutation) InviterID() (id int, exists bool) {
	if m.inviter != nil {
		return *m.inviter, true
	}
	return
}

// InviterIDs returns the "inviter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InviterID instead. It exists only for internal usage by the builders.
func (m *InvitationMutation) InviterIDs() (ids []int) {
	if id := m.inviter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInviter resets all changes to the "inviter" edge.
func (m *InvitationMutation) ResetInviter() {
	m.inviter = nil
	m.clearedinviter = false
}

// Where appends a list predicates to the InvitationMutation builder.
func (m *InvitationMutation) Where(ps ...predicate.Invitation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvitationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvitationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invitation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvitationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvitationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invitation).
func (m *InvitationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, invitation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invitation.FieldUpdatedAt)
	}
	if m.invitee_name != nil {
		fields = append(fields, invitation.FieldInviteeName)
	}
	if m.confirmation_code != nil {
		fields = append(fields, invitation.FieldConfirmationCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitation.FieldCreatedAt:
		return m.CreatedAt()
	case invitation.FieldUpdatedAt:
		return m.UpdatedAt()
	case invitation.FieldInviteeName:
		return m.InviteeName()
	case invitation.FieldConfirmationCode:
		return m.ConfirmationCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invitation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invitation.FieldInviteeName:
		return m.OldInviteeName(ctx)
	case invitation.FieldConfirmationCode:
		return m.OldConfirmationCode(ctx)
	}
	return nil, fmt.Errorf("unknown Invitation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invitation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invitation.FieldInviteeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteeName(v)
		return nil
	case invitation.FieldConfirmationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmationCode(v)
		return nil
	}
	return fmt.Errorf("unknown Invitation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Invitation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Invitation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationMutation) ResetField(name string) error {
	switch name {
	case invitation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invitation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invitation.FieldInviteeName:
		m.ResetInviteeName()
		return nil
	case invitation.FieldConfirmationCode:
		m.ResetConfirmationCode()
		return nil
	}
	return fmt.Errorf("unknown Invitation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.inviter != nil {
		edges = append(edges, invitation.EdgeInviter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitation.EdgeInviter:
		if id := m.inviter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinviter {
		edges = append(edges, invitation.EdgeInviter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationMutation) EdgeCleared(name string) bool {
	switch name {
	case invitation.EdgeInviter:
		return m.clearedinviter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationMutation) ClearEdge(name string) error {
	switch name {
	case invitation.EdgeInviter:
		m.ClearInviter()
		return nil
	}
	return fmt.Errorf("unknown Invitation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationMutation) ResetEdge(name string) error {
	switch name {
	case invitation.EdgeInviter:
		m.ResetInviter()
		return nil
	}
	return fmt.Errorf("unknown Invitation edge %s", name)
}

// LastSeenOnlineMutation represents an operation that mutates the LastSeenOnline nodes in the graph.
type LastSeenOnlineMutation struct {
	config
	op            Op
	typ           string
	id            *int
	seen_at       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*LastSeenOnline, error)
	predicates    []predicate.LastSeenOnline
}

var _ ent.Mutation = (*LastSeenOnlineMutation)(nil)

// lastseenonlineOption allows management of the mutation configuration using functional options.
type lastseenonlineOption func(*LastSeenOnlineMutation)

// newLastSeenOnlineMutation creates new mutation for the LastSeenOnline entity.
func newLastSeenOnlineMutation(c config, op Op, opts ...lastseenonlineOption) *LastSeenOnlineMutation {
	m := &LastSeenOnlineMutation{
		config:        c,
		op:            op,
		typ:           TypeLastSeenOnline,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLastSeenOnlineID sets the ID field of the mutation.
func withLastSeenOnlineID(id int) lastseenonlineOption {
	return func(m *LastSeenOnlineMutation) {
		var (
			err   error
			once  sync.Once
			value *LastSeenOnline
		)
		m.oldValue = func(ctx context.Context) (*LastSeenOnline, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LastSeenOnline.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLastSeenOnline sets the old LastSeenOnline of the mutation.
func withLastSeenOnline(node *LastSeenOnline) lastseenonlineOption {
	return func(m *LastSeenOnlineMutation) {
		m.oldValue = func(context.Context) (*LastSeenOnline, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LastSeenOnlineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LastSeenOnlineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LastSeenOnlineMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LastSeenOnlineMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LastSeenOnline.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeenAt sets the "seen_at" field.
func (m *LastSeenOnlineMutation) SetSeenAt(t time.Time) {
	m.seen_at = &t
}

// SeenAt returns the value of the "seen_at" field in the mutation.
func (m *LastSeenOnlineMutation) SeenAt() (r time.Time, exists bool) {
	v := m.seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSeenAt returns the old "seen_at" field's value of the LastSeenOnline entity.
// If the LastSeenOnline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LastSeenOnlineMutation) OldSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeenAt: %w", err)
	}
	return oldValue.SeenAt, nil
}

// ResetSeenAt resets all changes to the "seen_at" field.
func (m *LastSeenOnlineMutation) ResetSeenAt() {
	m.seen_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *LastSeenOnlineMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *LastSeenOnlineMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LastSeenOnlineMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *LastSeenOnlineMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LastSeenOnlineMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LastSeenOnlineMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the LastSeenOnlineMutation builder.
func (m *LastSeenOnlineMutation) Where(ps ...predicate.LastSeenOnline) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LastSeenOnlineMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LastSeenOnlineMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LastSeenOnline, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LastSeenOnlineMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LastSeenOnlineMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LastSeenOnline).
func (m *LastSeenOnlineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LastSeenOnlineMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.seen_at != nil {
		fields = append(fields, lastseenonline.FieldSeenAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LastSeenOnlineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lastseenonline.FieldSeenAt:
		return m.SeenAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LastSeenOnlineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lastseenonline.FieldSeenAt:
		return m.OldSeenAt(ctx)
	}
	return nil, fmt.Errorf("unknown LastSeenOnline field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LastSeenOnlineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lastseenonline.FieldSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeenAt(v)
		return nil
	}
	return fmt.Errorf("unknown LastSeenOnline field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LastSeenOnlineMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LastSeenOnlineMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LastSeenOnlineMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LastSeenOnline numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LastSeenOnlineMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LastSeenOnlineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LastSeenOnlineMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LastSeenOnline nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LastSeenOnlineMutation) ResetField(name string) error {
	switch name {
	case lastseenonline.FieldSeenAt:
		m.ResetSeenAt()
		return nil
	}
	return fmt.Errorf("unknown LastSeenOnline field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LastSeenOnlineMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, lastseenonline.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LastSeenOnlineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lastseenonline.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LastSeenOnlineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LastSeenOnlineMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LastSeenOnlineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, lastseenonline.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LastSeenOnlineMutation) EdgeCleared(name string) bool {
	switch name {
	case lastseenonline.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LastSeenOnlineMutation) ClearEdge(name string) error {
	switch name {
	case lastseenonline.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown LastSeenOnline unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LastSeenOnlineMutation) ResetEdge(name string) error {
	switch name {
	case lastseenonline.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown LastSeenOnline edge %s", name)
}

// MonthlySubscriptionMutation represents an operation that mutates the MonthlySubscription nodes in the graph.
type MonthlySubscriptionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	product            *monthlysubscription.Product
	is_active          *bool
	paid               *bool
	is_trial           *bool
	started_at         *time.Time
	expired_on         *time.Time
	cancelled_at       *time.Time
	clearedFields      map[string]struct{}
	benefactors        map[int]struct{}
	removedbenefactors map[int]struct{}
	clearedbenefactors bool
	payer              *int
	clearedpayer       bool
	done               bool
	oldValue           func(context.Context) (*MonthlySubscription, error)
	predicates         []predicate.MonthlySubscription
}

var _ ent.Mutation = (*MonthlySubscriptionMutation)(nil)

// monthlysubscriptionOption allows management of the mutation configuration using functional options.
type monthlysubscriptionOption func(*MonthlySubscriptionMutation)

// newMonthlySubscriptionMutation creates new mutation for the MonthlySubscription entity.
func newMonthlySubscriptionMutation(c config, op Op, opts ...monthlysubscriptionOption) *MonthlySubscriptionMutation {
	m := &MonthlySubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeMonthlySubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMonthlySubscriptionID sets the ID field of the mutation.
func withMonthlySubscriptionID(id int) monthlysubscriptionOption {
	return func(m *MonthlySubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *MonthlySubscription
		)
		m.oldValue = func(ctx context.Context) (*MonthlySubscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MonthlySubscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMonthlySubscription sets the old MonthlySubscription of the mutation.
func withMonthlySubscription(node *MonthlySubscription) monthlysubscriptionOption {
	return func(m *MonthlySubscriptionMutation) {
		m.oldValue = func(context.Context) (*MonthlySubscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MonthlySubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MonthlySubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MonthlySubscriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MonthlySubscriptionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MonthlySubscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MonthlySubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MonthlySubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MonthlySubscription entity.
// If the MonthlySubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonthlySubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MonthlySubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MonthlySubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MonthlySubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MonthlySubscription entity.
// If the MonthlySubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonthlySubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MonthlySubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProduct sets the "product" field.
func (m *MonthlySubscriptionMutation) SetProduct(value monthlysubscription.Product) {
	m.product = &value
}

// Product returns the value of the "product" field in the mutation.
func (m *MonthlySubscriptionMutation) Product() (r monthlysubscription.Product, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProduct returns the old "product" field's value of the MonthlySubscription entity.
// If the MonthlySubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonthlySubscriptionMutation) OldProduct(ctx context.Context) (v monthlysubscription.Product, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProduct is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProduct requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProduct: %w", err)
	}
	return oldValue.Product, nil
}

// ResetProduct resets all changes to the "product" field.
func (m *MonthlySubscriptionMutation) ResetProduct() {
	m.product = nil
}

// SetIsActive sets the "is_active" field.
func (m *MonthlySubscriptionMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *MonthlySubscriptionMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the MonthlySubscription entity.
// If the MonthlySubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonthlySubscriptionMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *MonthlySubscriptionMutation) ResetIsActive() {
	m.is_active = nil
}

// SetPaid sets the "paid" field.
func (m *MonthlySubscriptionMutation) SetPaid(b bool) {
	m.paid = &b
}

// Paid returns the value of the "paid" field in the mutation.
func (m *MonthlySubscriptionMutation) Paid() (r bool, exists bool) {
	v := m.paid
	if v == nil {
		return
	}
	return *v, true
}

// OldPaid returns the old "paid" field's value of the MonthlySubscription entity.
// If the MonthlySubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonthlySubscriptionMutation) OldPaid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaid: %w", err)
	}
	return oldValue.Paid, nil
}

// ResetPaid resets all changes to the "paid" field.
func (m *MonthlySubscriptionMutation) ResetPaid() {
	m.paid = nil
}

// SetIsTrial sets the "is_trial" field.
func (m *MonthlySubscriptionMutation) SetIsTrial(b bool) {
	m.is_trial = &b
}

// IsTrial returns the value of the "is_trial" field in the mutation.
func (m *MonthlySubscriptionMutation) IsTrial() (r bool, exists bool) {
	v := m.is_trial
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTrial returns the old "is_trial" field's value of the MonthlySubscription entity.
// If the MonthlySubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonthlySubscriptionMutation) OldIsTrial(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTrial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTrial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTrial: %w", err)
	}
	return oldValue.IsTrial, nil
}

// ResetIsTrial resets all changes to the "is_trial" field.
func (m *MonthlySubscriptionMutation) ResetIsTrial() {
	m.is_trial = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MonthlySubscriptionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MonthlySubscriptionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MonthlySubscription entity.
// If the MonthlySubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonthlySubscriptionMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *MonthlySubscriptionMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[monthlysubscription.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *MonthlySubscriptionMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[monthlysubscription.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MonthlySubscriptionMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, monthlysubscription.FieldStartedAt)
}

// SetExpiredOn sets the "expired_on" field.
func (m *MonthlySubscriptionMutation) SetExpiredOn(t time.Time) {
	m.expired_on = &t
}

// ExpiredOn returns the value of the "expired_on" field in the mutation.
func (m *MonthlySubscriptionMutation) ExpiredOn() (r time.Time, exists bool) {
	v := m.expired_on
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredOn returns the old "expired_on" field's value of the MonthlySubscription entity.
// If the MonthlySubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonthlySubscriptionMutation) OldExpiredOn(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredOn: %w", err)
	}
	return oldValue.ExpiredOn, nil
}

// ClearExpiredOn clears the value of the "expired_on" field.
func (m *MonthlySubscriptionMutation) ClearExpiredOn() {
	m.expired_on = nil
	m.clearedFields[monthlysubscription.FieldExpiredOn] = struct{}{}
}

// ExpiredOnCleared returns if the "expired_on" field was cleared in this mutation.
func (m *MonthlySubscriptionMutation) ExpiredOnCleared() bool {
	_, ok := m.clearedFields[monthlysubscription.FieldExpiredOn]
	return ok
}

// ResetExpiredOn resets all changes to the "expired_on" field.
func (m *MonthlySubscriptionMutation) ResetExpiredOn() {
	m.expired_on = nil
	delete(m.clearedFields, monthlysubscription.FieldExpiredOn)
}

// SetCancelledAt sets the "cancelled_at" field.
func (m *MonthlySubscriptionMutation) SetCancelledAt(t time.Time) {
	m.cancelled_at = &t
}

// CancelledAt returns the value of the "cancelled_at" field in the mutation.
func (m *MonthlySubscriptionMutation) CancelledAt() (r time.Time, exists bool) {
	v := m.cancelled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelledAt returns the old "cancelled_at" field's value of the MonthlySubscription entity.
// If the MonthlySubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonthlySubscriptionMutation) OldCancelledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelledAt: %w", err)
	}
	return oldValue.CancelledAt, nil
}

// ClearCancelledAt clears the value of the "cancelled_at" field.
func (m *MonthlySubscriptionMutation) ClearCancelledAt() {
	m.cancelled_at = nil
	m.clearedFields[monthlysubscription.FieldCancelledAt] = struct{}{}
}

// CancelledAtCleared returns if the "cancelled_at" field was cleared in this mutation.
func (m *MonthlySubscriptionMutation) CancelledAtCleared() bool {
	_, ok := m.clearedFields[monthlysubscription.FieldCancelledAt]
	return ok
}

// ResetCancelledAt resets all changes to the "cancelled_at" field.
func (m *MonthlySubscriptionMutation) ResetCancelledAt() {
	m.cancelled_at = nil
	delete(m.clearedFields, monthlysubscription.FieldCancelledAt)
}

// SetPayingProfileID sets the "paying_profile_id" field.
func (m *MonthlySubscriptionMutation) SetPayingProfileID(i int) {
	m.payer = &i
}

// PayingProfileID returns the value of the "paying_profile_id" field in the mutation.
func (m *MonthlySubscriptionMutation) PayingProfileID() (r int, exists bool) {
	v := m.payer
	if v == nil {
		return
	}
	return *v, true
}

// OldPayingProfileID returns the old "paying_profile_id" field's value of the MonthlySubscription entity.
// If the MonthlySubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonthlySubscriptionMutation) OldPayingProfileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayingProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayingProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayingProfileID: %w", err)
	}
	return oldValue.PayingProfileID, nil
}

// ResetPayingProfileID resets all changes to the "paying_profile_id" field.
func (m *MonthlySubscriptionMutation) ResetPayingProfileID() {
	m.payer = nil
}

// AddBenefactorIDs adds the "benefactors" edge to the Profile entity by ids.
func (m *MonthlySubscriptionMutation) AddBenefactorIDs(ids ...int) {
	if m.benefactors == nil {
		m.benefactors = make(map[int]struct{})
	}
	for i := range ids {
		m.benefactors[ids[i]] = struct{}{}
	}
}

// ClearBenefactors clears the "benefactors" edge to the Profile entity.
func (m *MonthlySubscriptionMutation) ClearBenefactors() {
	m.clearedbenefactors = true
}

// BenefactorsCleared reports if the "benefactors" edge to the Profile entity was cleared.
func (m *MonthlySubscriptionMutation) BenefactorsCleared() bool {
	return m.clearedbenefactors
}

// RemoveBenefactorIDs removes the "benefactors" edge to the Profile entity by IDs.
func (m *MonthlySubscriptionMutation) RemoveBenefactorIDs(ids ...int) {
	if m.removedbenefactors == nil {
		m.removedbenefactors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.benefactors, ids[i])
		m.removedbenefactors[ids[i]] = struct{}{}
	}
}

// RemovedBenefactors returns the removed IDs of the "benefactors" edge to the Profile entity.
func (m *MonthlySubscriptionMutation) RemovedBenefactorsIDs() (ids []int) {
	for id := range m.removedbenefactors {
		ids = append(ids, id)
	}
	return
}

// BenefactorsIDs returns the "benefactors" edge IDs in the mutation.
func (m *MonthlySubscriptionMutation) BenefactorsIDs() (ids []int) {
	for id := range m.benefactors {
		ids = append(ids, id)
	}
	return
}

// ResetBenefactors resets all changes to the "benefactors" edge.
func (m *MonthlySubscriptionMutation) ResetBenefactors() {
	m.benefactors = nil
	m.clearedbenefactors = false
	m.removedbenefactors = nil
}

// SetPayerID sets the "payer" edge to the Profile entity by id.
func (m *MonthlySubscriptionMutation) SetPayerID(id int) {
	m.payer = &id
}

// ClearPayer clears the "payer" edge to the Profile entity.
func (m *MonthlySubscriptionMutation) ClearPayer() {
	m.clearedpayer = true
	m.clearedFields[monthlysubscription.FieldPayingProfileID] = struct{}{}
}

// PayerCleared reports if the "payer" edge to the Profile entity was cleared.
func (m *MonthlySubscriptionMutation) PayerCleared() bool {
	return m.clearedpayer
}

// PayerID returns the "payer" edge ID in the mutation.
func (m *MonthlySubscriptionMutation) PayerID() (id int, exists bool) {
	if m.payer != nil {
		return *m.payer, true
	}
	return
}

// PayerIDs returns the "payer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PayerID instead. It exists only for internal usage by the builders.
func (m *MonthlySubscriptionMutation) PayerIDs() (ids []int) {
	if id := m.payer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPayer resets all changes to the "payer" edge.
func (m *MonthlySubscriptionMutation) ResetPayer() {
	m.payer = nil
	m.clearedpayer = false
}

// Where appends a list predicates to the MonthlySubscriptionMutation builder.
func (m *MonthlySubscriptionMutation) Where(ps ...predicate.MonthlySubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MonthlySubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MonthlySubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MonthlySubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MonthlySubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MonthlySubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MonthlySubscription).
func (m *MonthlySubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MonthlySubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, monthlysubscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, monthlysubscription.FieldUpdatedAt)
	}
	if m.product != nil {
		fields = append(fields, monthlysubscription.FieldProduct)
	}
	if m.is_active != nil {
		fields = append(fields, monthlysubscription.FieldIsActive)
	}
	if m.paid != nil {
		fields = append(fields, monthlysubscription.FieldPaid)
	}
	if m.is_trial != nil {
		fields = append(fields, monthlysubscription.FieldIsTrial)
	}
	if m.started_at != nil {
		fields = append(fields, monthlysubscription.FieldStartedAt)
	}
	if m.expired_on != nil {
		fields = append(fields, monthlysubscription.FieldExpiredOn)
	}
	if m.cancelled_at != nil {
		fields = append(fields, monthlysubscription.FieldCancelledAt)
	}
	if m.payer != nil {
		fields = append(fields, monthlysubscription.FieldPayingProfileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MonthlySubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case monthlysubscription.FieldCreatedAt:
		return m.CreatedAt()
	case monthlysubscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case monthlysubscription.FieldProduct:
		return m.Product()
	case monthlysubscription.FieldIsActive:
		return m.IsActive()
	case monthlysubscription.FieldPaid:
		return m.Paid()
	case monthlysubscription.FieldIsTrial:
		return m.IsTrial()
	case monthlysubscription.FieldStartedAt:
		return m.StartedAt()
	case monthlysubscription.FieldExpiredOn:
		return m.ExpiredOn()
	case monthlysubscription.FieldCancelledAt:
		return m.CancelledAt()
	case monthlysubscription.FieldPayingProfileID:
		return m.PayingProfileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MonthlySubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case monthlysubscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case monthlysubscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case monthlysubscription.FieldProduct:
		return m.OldProduct(ctx)
	case monthlysubscription.FieldIsActive:
		return m.OldIsActive(ctx)
	case monthlysubscription.FieldPaid:
		return m.OldPaid(ctx)
	case monthlysubscription.FieldIsTrial:
		return m.OldIsTrial(ctx)
	case monthlysubscription.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case monthlysubscription.FieldExpiredOn:
		return m.OldExpiredOn(ctx)
	case monthlysubscription.FieldCancelledAt:
		return m.OldCancelledAt(ctx)
	case monthlysubscription.FieldPayingProfileID:
		return m.OldPayingProfileID(ctx)
	}
	return nil, fmt.Errorf("unknown MonthlySubscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MonthlySubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case monthlysubscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case monthlysubscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case monthlysubscription.FieldProduct:
		v, ok := value.(monthlysubscription.Product)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProduct(v)
		return nil
	case monthlysubscription.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case monthlysubscription.FieldPaid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaid(v)
		return nil
	case monthlysubscription.FieldIsTrial:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTrial(v)
		return nil
	case monthlysubscription.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case monthlysubscription.FieldExpiredOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredOn(v)
		return nil
	case monthlysubscription.FieldCancelledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelledAt(v)
		return nil
	case monthlysubscription.FieldPayingProfileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayingProfileID(v)
		return nil
	}
	return fmt.Errorf("unknown MonthlySubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MonthlySubscriptionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MonthlySubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MonthlySubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MonthlySubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MonthlySubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(monthlysubscription.FieldStartedAt) {
		fields = append(fields, monthlysubscription.FieldStartedAt)
	}
	if m.FieldCleared(monthlysubscription.FieldExpiredOn) {
		fields = append(fields, monthlysubscription.FieldExpiredOn)
	}
	if m.FieldCleared(monthlysubscription.FieldCancelledAt) {
		fields = append(fields, monthlysubscription.FieldCancelledAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MonthlySubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MonthlySubscriptionMutation) ClearField(name string) error {
	switch name {
	case monthlysubscription.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case monthlysubscription.FieldExpiredOn:
		m.ClearExpiredOn()
		return nil
	case monthlysubscription.FieldCancelledAt:
		m.ClearCancelledAt()
		return nil
	}
	return fmt.Errorf("unknown MonthlySubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MonthlySubscriptionMutation) ResetField(name string) error {
	switch name {
	case monthlysubscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case monthlysubscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case monthlysubscription.FieldProduct:
		m.ResetProduct()
		return nil
	case monthlysubscription.FieldIsActive:
		m.ResetIsActive()
		return nil
	case monthlysubscription.FieldPaid:
		m.ResetPaid()
		return nil
	case monthlysubscription.FieldIsTrial:
		m.ResetIsTrial()
		return nil
	case monthlysubscription.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case monthlysubscription.FieldExpiredOn:
		m.ResetExpiredOn()
		return nil
	case monthlysubscription.FieldCancelledAt:
		m.ResetCancelledAt()
		return nil
	case monthlysubscription.FieldPayingProfileID:
		m.ResetPayingProfileID()
		return nil
	}
	return fmt.Errorf("unknown MonthlySubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MonthlySubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.benefactors != nil {
		edges = append(edges, monthlysubscription.EdgeBenefactors)
	}
	if m.payer != nil {
		edges = append(edges, monthlysubscription.EdgePayer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MonthlySubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case monthlysubscription.EdgeBenefactors:
		ids := make([]ent.Value, 0, len(m.benefactors))
		for id := range m.benefactors {
			ids = append(ids, id)
		}
		return ids
	case monthlysubscription.EdgePayer:
		if id := m.payer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MonthlySubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbenefactors != nil {
		edges = append(edges, monthlysubscription.EdgeBenefactors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MonthlySubscriptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case monthlysubscription.EdgeBenefactors:
		ids := make([]ent.Value, 0, len(m.removedbenefactors))
		for id := range m.removedbenefactors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MonthlySubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbenefactors {
		edges = append(edges, monthlysubscription.EdgeBenefactors)
	}
	if m.clearedpayer {
		edges = append(edges, monthlysubscription.EdgePayer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MonthlySubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case monthlysubscription.EdgeBenefactors:
		return m.clearedbenefactors
	case monthlysubscription.EdgePayer:
		return m.clearedpayer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MonthlySubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case monthlysubscription.EdgePayer:
		m.ClearPayer()
		return nil
	}
	return fmt.Errorf("unknown MonthlySubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MonthlySubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case monthlysubscription.EdgeBenefactors:
		m.ResetBenefactors()
		return nil
	case monthlysubscription.EdgePayer:
		m.ResetPayer()
		return nil
	}
	return fmt.Errorf("unknown MonthlySubscription edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *int
	created_at                            *time.Time
	updated_at                            *time.Time
	_type                                 *notification.Type
	title                                 *string
	text                                  *string
	link                                  *string
	read                                  *bool
	read_at                               *time.Time
	profile_id_who_caused_notification    *int
	addprofile_id_who_caused_notification *int
	resource_id_tied_to_notif             *int
	addresource_id_tied_to_notif          *int
	read_in_notifications_center          *bool
	clearedFields                         map[string]struct{}
	profile                               *int
	clearedprofile                        bool
	done                                  bool
	oldValue                              func(context.Context) (*Notification, error)
	predicates                            []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id int) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *NotificationMutation) SetType(n notification.Type) {
	m._type = &n
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationMutation) GetType() (r notification.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldType(ctx context.Context) (v notification.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationMutation) ResetType() {
	m._type = nil
}

// SetTitle sets the "title" field.
func (m *NotificationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *NotificationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *NotificationMutation) ResetTitle() {
	m.title = nil
}

// SetText sets the "text" field.
func (m *NotificationMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *NotificationMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *NotificationMutation) ResetText() {
	m.text = nil
}

// SetLink sets the "link" field.
func (m *NotificationMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *NotificationMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldLink(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *NotificationMutation) ClearLink() {
	m.link = nil
	m.clearedFields[notification.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *NotificationMutation) LinkCleared() bool {
	_, ok := m.clearedFields[notification.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *NotificationMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, notification.FieldLink)
}

// SetRead sets the "read" field.
func (m *NotificationMutation) SetRead(b bool) {
	m.read = &b
}

// Read returns the value of the "read" field in the mutation.
func (m *NotificationMutation) Read() (r bool, exists bool) {
	v := m.read
	if v == nil {
		return
	}
	return *v, true
}

// OldRead returns the old "read" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRead: %w", err)
	}
	return oldValue.Read, nil
}

// ResetRead resets all changes to the "read" field.
func (m *NotificationMutation) ResetRead() {
	m.read = nil
}

// SetReadAt sets the "read_at" field.
func (m *NotificationMutation) SetReadAt(t time.Time) {
	m.read_at = &t
}

// ReadAt returns the value of the "read_at" field in the mutation.
func (m *NotificationMutation) ReadAt() (r time.Time, exists bool) {
	v := m.read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReadAt returns the old "read_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldReadAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadAt: %w", err)
	}
	return oldValue.ReadAt, nil
}

// ClearReadAt clears the value of the "read_at" field.
func (m *NotificationMutation) ClearReadAt() {
	m.read_at = nil
	m.clearedFields[notification.FieldReadAt] = struct{}{}
}

// ReadAtCleared returns if the "read_at" field was cleared in this mutation.
func (m *NotificationMutation) ReadAtCleared() bool {
	_, ok := m.clearedFields[notification.FieldReadAt]
	return ok
}

// ResetReadAt resets all changes to the "read_at" field.
func (m *NotificationMutation) ResetReadAt() {
	m.read_at = nil
	delete(m.clearedFields, notification.FieldReadAt)
}

// SetProfileIDWhoCausedNotification sets the "profile_id_who_caused_notification" field.
func (m *NotificationMutation) SetProfileIDWhoCausedNotification(i int) {
	m.profile_id_who_caused_notification = &i
	m.addprofile_id_who_caused_notification = nil
}

// ProfileIDWhoCausedNotification returns the value of the "profile_id_who_caused_notification" field in the mutation.
func (m *NotificationMutation) ProfileIDWhoCausedNotification() (r int, exists bool) {
	v := m.profile_id_who_caused_notification
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileIDWhoCausedNotification returns the old "profile_id_who_caused_notification" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldProfileIDWhoCausedNotification(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileIDWhoCausedNotification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileIDWhoCausedNotification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileIDWhoCausedNotification: %w", err)
	}
	return oldValue.ProfileIDWhoCausedNotification, nil
}

// AddProfileIDWhoCausedNotification adds i to the "profile_id_who_caused_notification" field.
func (m *NotificationMutation) AddProfileIDWhoCausedNotification(i int) {
	if m.addprofile_id_who_caused_notification != nil {
		*m.addprofile_id_who_caused_notification += i
	} else {
		m.addprofile_id_who_caused_notification = &i
	}
}

// AddedProfileIDWhoCausedNotification returns the value that was added to the "profile_id_who_caused_notification" field in this mutation.
func (m *NotificationMutation) AddedProfileIDWhoCausedNotification() (r int, exists bool) {
	v := m.addprofile_id_who_caused_notification
	if v == nil {
		return
	}
	return *v, true
}

// ClearProfileIDWhoCausedNotification clears the value of the "profile_id_who_caused_notification" field.
func (m *NotificationMutation) ClearProfileIDWhoCausedNotification() {
	m.profile_id_who_caused_notification = nil
	m.addprofile_id_who_caused_notification = nil
	m.clearedFields[notification.FieldProfileIDWhoCausedNotification] = struct{}{}
}

// ProfileIDWhoCausedNotificationCleared returns if the "profile_id_who_caused_notification" field was cleared in this mutation.
func (m *NotificationMutation) ProfileIDWhoCausedNotificationCleared() bool {
	_, ok := m.clearedFields[notification.FieldProfileIDWhoCausedNotification]
	return ok
}

// ResetProfileIDWhoCausedNotification resets all changes to the "profile_id_who_caused_notification" field.
func (m *NotificationMutation) ResetProfileIDWhoCausedNotification() {
	m.profile_id_who_caused_notification = nil
	m.addprofile_id_who_caused_notification = nil
	delete(m.clearedFields, notification.FieldProfileIDWhoCausedNotification)
}

// SetResourceIDTiedToNotif sets the "resource_id_tied_to_notif" field.
func (m *NotificationMutation) SetResourceIDTiedToNotif(i int) {
	m.resource_id_tied_to_notif = &i
	m.addresource_id_tied_to_notif = nil
}

// ResourceIDTiedToNotif returns the value of the "resource_id_tied_to_notif" field in the mutation.
func (m *NotificationMutation) ResourceIDTiedToNotif() (r int, exists bool) {
	v := m.resource_id_tied_to_notif
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceIDTiedToNotif returns the old "resource_id_tied_to_notif" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldResourceIDTiedToNotif(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceIDTiedToNotif is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceIDTiedToNotif requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceIDTiedToNotif: %w", err)
	}
	return oldValue.ResourceIDTiedToNotif, nil
}

// AddResourceIDTiedToNotif adds i to the "resource_id_tied_to_notif" field.
func (m *NotificationMutation) AddResourceIDTiedToNotif(i int) {
	if m.addresource_id_tied_to_notif != nil {
		*m.addresource_id_tied_to_notif += i
	} else {
		m.addresource_id_tied_to_notif = &i
	}
}

// AddedResourceIDTiedToNotif returns the value that was added to the "resource_id_tied_to_notif" field in this mutation.
func (m *NotificationMutation) AddedResourceIDTiedToNotif() (r int, exists bool) {
	v := m.addresource_id_tied_to_notif
	if v == nil {
		return
	}
	return *v, true
}

// ClearResourceIDTiedToNotif clears the value of the "resource_id_tied_to_notif" field.
func (m *NotificationMutation) ClearResourceIDTiedToNotif() {
	m.resource_id_tied_to_notif = nil
	m.addresource_id_tied_to_notif = nil
	m.clearedFields[notification.FieldResourceIDTiedToNotif] = struct{}{}
}

// ResourceIDTiedToNotifCleared returns if the "resource_id_tied_to_notif" field was cleared in this mutation.
func (m *NotificationMutation) ResourceIDTiedToNotifCleared() bool {
	_, ok := m.clearedFields[notification.FieldResourceIDTiedToNotif]
	return ok
}

// ResetResourceIDTiedToNotif resets all changes to the "resource_id_tied_to_notif" field.
func (m *NotificationMutation) ResetResourceIDTiedToNotif() {
	m.resource_id_tied_to_notif = nil
	m.addresource_id_tied_to_notif = nil
	delete(m.clearedFields, notification.FieldResourceIDTiedToNotif)
}

// SetReadInNotificationsCenter sets the "read_in_notifications_center" field.
func (m *NotificationMutation) SetReadInNotificationsCenter(b bool) {
	m.read_in_notifications_center = &b
}

// ReadInNotificationsCenter returns the value of the "read_in_notifications_center" field in the mutation.
func (m *NotificationMutation) ReadInNotificationsCenter() (r bool, exists bool) {
	v := m.read_in_notifications_center
	if v == nil {
		return
	}
	return *v, true
}

// OldReadInNotificationsCenter returns the old "read_in_notifications_center" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldReadInNotificationsCenter(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadInNotificationsCenter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadInNotificationsCenter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadInNotificationsCenter: %w", err)
	}
	return oldValue.ReadInNotificationsCenter, nil
}

// ClearReadInNotificationsCenter clears the value of the "read_in_notifications_center" field.
func (m *NotificationMutation) ClearReadInNotificationsCenter() {
	m.read_in_notifications_center = nil
	m.clearedFields[notification.FieldReadInNotificationsCenter] = struct{}{}
}

// ReadInNotificationsCenterCleared returns if the "read_in_notifications_center" field was cleared in this mutation.
func (m *NotificationMutation) ReadInNotificationsCenterCleared() bool {
	_, ok := m.clearedFields[notification.FieldReadInNotificationsCenter]
	return ok
}

// ResetReadInNotificationsCenter resets all changes to the "read_in_notifications_center" field.
func (m *NotificationMutation) ResetReadInNotificationsCenter() {
	m.read_in_notifications_center = nil
	delete(m.clearedFields, notification.FieldReadInNotificationsCenter)
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *NotificationMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *NotificationMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *NotificationMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *NotificationMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *NotificationMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notification.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, notification.FieldType)
	}
	if m.title != nil {
		fields = append(fields, notification.FieldTitle)
	}
	if m.text != nil {
		fields = append(fields, notification.FieldText)
	}
	if m.link != nil {
		fields = append(fields, notification.FieldLink)
	}
	if m.read != nil {
		fields = append(fields, notification.FieldRead)
	}
	if m.read_at != nil {
		fields = append(fields, notification.FieldReadAt)
	}
	if m.profile_id_who_caused_notification != nil {
		fields = append(fields, notification.FieldProfileIDWhoCausedNotification)
	}
	if m.resource_id_tied_to_notif != nil {
		fields = append(fields, notification.FieldResourceIDTiedToNotif)
	}
	if m.read_in_notifications_center != nil {
		fields = append(fields, notification.FieldReadInNotificationsCenter)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldUpdatedAt:
		return m.UpdatedAt()
	case notification.FieldType:
		return m.GetType()
	case notification.FieldTitle:
		return m.Title()
	case notification.FieldText:
		return m.Text()
	case notification.FieldLink:
		return m.Link()
	case notification.FieldRead:
		return m.Read()
	case notification.FieldReadAt:
		return m.ReadAt()
	case notification.FieldProfileIDWhoCausedNotification:
		return m.ProfileIDWhoCausedNotification()
	case notification.FieldResourceIDTiedToNotif:
		return m.ResourceIDTiedToNotif()
	case notification.FieldReadInNotificationsCenter:
		return m.ReadInNotificationsCenter()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notification.FieldType:
		return m.OldType(ctx)
	case notification.FieldTitle:
		return m.OldTitle(ctx)
	case notification.FieldText:
		return m.OldText(ctx)
	case notification.FieldLink:
		return m.OldLink(ctx)
	case notification.FieldRead:
		return m.OldRead(ctx)
	case notification.FieldReadAt:
		return m.OldReadAt(ctx)
	case notification.FieldProfileIDWhoCausedNotification:
		return m.OldProfileIDWhoCausedNotification(ctx)
	case notification.FieldResourceIDTiedToNotif:
		return m.OldResourceIDTiedToNotif(ctx)
	case notification.FieldReadInNotificationsCenter:
		return m.OldReadInNotificationsCenter(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notification.FieldType:
		v, ok := value.(notification.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notification.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case notification.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case notification.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case notification.FieldRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRead(v)
		return nil
	case notification.FieldReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadAt(v)
		return nil
	case notification.FieldProfileIDWhoCausedNotification:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileIDWhoCausedNotification(v)
		return nil
	case notification.FieldResourceIDTiedToNotif:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceIDTiedToNotif(v)
		return nil
	case notification.FieldReadInNotificationsCenter:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadInNotificationsCenter(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	var fields []string
	if m.addprofile_id_who_caused_notification != nil {
		fields = append(fields, notification.FieldProfileIDWhoCausedNotification)
	}
	if m.addresource_id_tied_to_notif != nil {
		fields = append(fields, notification.FieldResourceIDTiedToNotif)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldProfileIDWhoCausedNotification:
		return m.AddedProfileIDWhoCausedNotification()
	case notification.FieldResourceIDTiedToNotif:
		return m.AddedResourceIDTiedToNotif()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notification.FieldProfileIDWhoCausedNotification:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfileIDWhoCausedNotification(v)
		return nil
	case notification.FieldResourceIDTiedToNotif:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResourceIDTiedToNotif(v)
		return nil
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldLink) {
		fields = append(fields, notification.FieldLink)
	}
	if m.FieldCleared(notification.FieldReadAt) {
		fields = append(fields, notification.FieldReadAt)
	}
	if m.FieldCleared(notification.FieldProfileIDWhoCausedNotification) {
		fields = append(fields, notification.FieldProfileIDWhoCausedNotification)
	}
	if m.FieldCleared(notification.FieldResourceIDTiedToNotif) {
		fields = append(fields, notification.FieldResourceIDTiedToNotif)
	}
	if m.FieldCleared(notification.FieldReadInNotificationsCenter) {
		fields = append(fields, notification.FieldReadInNotificationsCenter)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldLink:
		m.ClearLink()
		return nil
	case notification.FieldReadAt:
		m.ClearReadAt()
		return nil
	case notification.FieldProfileIDWhoCausedNotification:
		m.ClearProfileIDWhoCausedNotification()
		return nil
	case notification.FieldResourceIDTiedToNotif:
		m.ClearResourceIDTiedToNotif()
		return nil
	case notification.FieldReadInNotificationsCenter:
		m.ClearReadInNotificationsCenter()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notification.FieldType:
		m.ResetType()
		return nil
	case notification.FieldTitle:
		m.ResetTitle()
		return nil
	case notification.FieldText:
		m.ResetText()
		return nil
	case notification.FieldLink:
		m.ResetLink()
		return nil
	case notification.FieldRead:
		m.ResetRead()
		return nil
	case notification.FieldReadAt:
		m.ResetReadAt()
		return nil
	case notification.FieldProfileIDWhoCausedNotification:
		m.ResetProfileIDWhoCausedNotification()
		return nil
	case notification.FieldResourceIDTiedToNotif:
		m.ResetResourceIDTiedToNotif()
		return nil
	case notification.FieldReadInNotificationsCenter:
		m.ResetReadInNotificationsCenter()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.profile != nil {
		edges = append(edges, notification.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprofile {
		edges = append(edges, notification.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	case notification.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// NotificationPermissionMutation represents an operation that mutates the NotificationPermission nodes in the graph.
type NotificationPermissionMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	permission     *notificationpermission.Permission
	platform       *notificationpermission.Platform
	token          *string
	clearedFields  map[string]struct{}
	profile        *int
	clearedprofile bool
	done           bool
	oldValue       func(context.Context) (*NotificationPermission, error)
	predicates     []predicate.NotificationPermission
}

var _ ent.Mutation = (*NotificationPermissionMutation)(nil)

// notificationpermissionOption allows management of the mutation configuration using functional options.
type notificationpermissionOption func(*NotificationPermissionMutation)

// newNotificationPermissionMutation creates new mutation for the NotificationPermission entity.
func newNotificationPermissionMutation(c config, op Op, opts ...notificationpermissionOption) *NotificationPermissionMutation {
	m := &NotificationPermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationPermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationPermissionID sets the ID field of the mutation.
func withNotificationPermissionID(id int) notificationpermissionOption {
	return func(m *NotificationPermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationPermission
		)
		m.oldValue = func(ctx context.Context) (*NotificationPermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationPermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationPermission sets the old NotificationPermission of the mutation.
func withNotificationPermission(node *NotificationPermission) notificationpermissionOption {
	return func(m *NotificationPermissionMutation) {
		m.oldValue = func(context.Context) (*NotificationPermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationPermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationPermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationPermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationPermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationPermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationPermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationPermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationPermission entity.
// If the NotificationPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationPermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationPermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationPermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationPermission entity.
// If the NotificationPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationPermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPermission sets the "permission" field.
func (m *NotificationPermissionMutation) SetPermission(n notificationpermission.Permission) {
	m.permission = &n
}

// Permission returns the value of the "permission" field in the mutation.
func (m *NotificationPermissionMutation) Permission() (r notificationpermission.Permission, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermission returns the old "permission" field's value of the NotificationPermission entity.
// If the NotificationPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPermissionMutation) OldPermission(ctx context.Context) (v notificationpermission.Permission, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermission: %w", err)
	}
	return oldValue.Permission, nil
}

// ResetPermission resets all changes to the "permission" field.
func (m *NotificationPermissionMutation) ResetPermission() {
	m.permission = nil
}

// SetPlatform sets the "platform" field.
func (m *NotificationPermissionMutation) SetPlatform(n notificationpermission.Platform) {
	m.platform = &n
}

// Platform returns the value of the "platform" field in the mutation.
func (m *NotificationPermissionMutation) Platform() (r notificationpermission.Platform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the NotificationPermission entity.
// If the NotificationPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPermissionMutation) OldPlatform(ctx context.Context) (v notificationpermission.Platform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *NotificationPermissionMutation) ResetPlatform() {
	m.platform = nil
}

// SetProfileID sets the "profile_id" field.
func (m *NotificationPermissionMutation) SetProfileID(i int) {
	m.profile = &i
}

// ProfileID returns the value of the "profile_id" field in the mutation.
func (m *NotificationPermissionMutation) ProfileID() (r int, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileID returns the old "profile_id" field's value of the NotificationPermission entity.
// If the NotificationPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPermissionMutation) OldProfileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileID: %w", err)
	}
	return oldValue.ProfileID, nil
}

// ResetProfileID resets all changes to the "profile_id" field.
func (m *NotificationPermissionMutation) ResetProfileID() {
	m.profile = nil
}

// SetToken sets the "token" field.
func (m *NotificationPermissionMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *NotificationPermissionMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the NotificationPermission entity.
// If the NotificationPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPermissionMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *NotificationPermissionMutation) ResetToken() {
	m.token = nil
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *NotificationPermissionMutation) ClearProfile() {
	m.clearedprofile = true
	m.clearedFields[notificationpermission.FieldProfileID] = struct{}{}
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *NotificationPermissionMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *NotificationPermissionMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *NotificationPermissionMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the NotificationPermissionMutation builder.
func (m *NotificationPermissionMutation) Where(ps ...predicate.NotificationPermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationPermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationPermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationPermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationPermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationPermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationPermission).
func (m *NotificationPermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationPermissionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, notificationpermission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationpermission.FieldUpdatedAt)
	}
	if m.permission != nil {
		fields = append(fields, notificationpermission.FieldPermission)
	}
	if m.platform != nil {
		fields = append(fields, notificationpermission.FieldPlatform)
	}
	if m.profile != nil {
		fields = append(fields, notificationpermission.FieldProfileID)
	}
	if m.token != nil {
		fields = append(fields, notificationpermission.FieldToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationPermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationpermission.FieldCreatedAt:
		return m.CreatedAt()
	case notificationpermission.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationpermission.FieldPermission:
		return m.Permission()
	case notificationpermission.FieldPlatform:
		return m.Platform()
	case notificationpermission.FieldProfileID:
		return m.ProfileID()
	case notificationpermission.FieldToken:
		return m.Token()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationPermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationpermission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationpermission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationpermission.FieldPermission:
		return m.OldPermission(ctx)
	case notificationpermission.FieldPlatform:
		return m.OldPlatform(ctx)
	case notificationpermission.FieldProfileID:
		return m.OldProfileID(ctx)
	case notificationpermission.FieldToken:
		return m.OldToken(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationPermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationPermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationpermission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationpermission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationpermission.FieldPermission:
		v, ok := value.(notificationpermission.Permission)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermission(v)
		return nil
	case notificationpermission.FieldPlatform:
		v, ok := value.(notificationpermission.Platform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case notificationpermission.FieldProfileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileID(v)
		return nil
	case notificationpermission.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationPermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationPermissionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationPermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationPermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationPermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationPermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationPermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationPermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotificationPermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationPermissionMutation) ResetField(name string) error {
	switch name {
	case notificationpermission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationpermission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationpermission.FieldPermission:
		m.ResetPermission()
		return nil
	case notificationpermission.FieldPlatform:
		m.ResetPlatform()
		return nil
	case notificationpermission.FieldProfileID:
		m.ResetProfileID()
		return nil
	case notificationpermission.FieldToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown NotificationPermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationPermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.profile != nil {
		edges = append(edges, notificationpermission.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationPermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationpermission.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationPermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationPermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationPermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprofile {
		edges = append(edges, notificationpermission.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationPermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationpermission.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationPermissionMutation) ClearEdge(name string) error {
	switch name {
	case notificationpermission.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown NotificationPermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationPermissionMutation) ResetEdge(name string) error {
	switch name {
	case notificationpermission.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown NotificationPermission edge %s", name)
}

// NotificationTimeMutation represents an operation that mutates the NotificationTime nodes in the graph.
type NotificationTimeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	_type          *notificationtime.Type
	send_minute    *int
	addsend_minute *int
	clearedFields  map[string]struct{}
	profile        *int
	clearedprofile bool
	done           bool
	oldValue       func(context.Context) (*NotificationTime, error)
	predicates     []predicate.NotificationTime
}

var _ ent.Mutation = (*NotificationTimeMutation)(nil)

// notificationtimeOption allows management of the mutation configuration using functional options.
type notificationtimeOption func(*NotificationTimeMutation)

// newNotificationTimeMutation creates new mutation for the NotificationTime entity.
func newNotificationTimeMutation(c config, op Op, opts ...notificationtimeOption) *NotificationTimeMutation {
	m := &NotificationTimeMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationTime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationTimeID sets the ID field of the mutation.
func withNotificationTimeID(id int) notificationtimeOption {
	return func(m *NotificationTimeMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationTime
		)
		m.oldValue = func(ctx context.Context) (*NotificationTime, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationTime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationTime sets the old NotificationTime of the mutation.
func withNotificationTime(node *NotificationTime) notificationtimeOption {
	return func(m *NotificationTimeMutation) {
		m.oldValue = func(context.Context) (*NotificationTime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationTimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationTimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationTimeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationTimeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationTime.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationTimeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationTimeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationTime entity.
// If the NotificationTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTimeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationTimeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationTimeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationTimeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationTime entity.
// If the NotificationTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTimeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationTimeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *NotificationTimeMutation) SetType(n notificationtime.Type) {
	m._type = &n
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationTimeMutation) GetType() (r notificationtime.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationTime entity.
// If the NotificationTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTimeMutation) OldType(ctx context.Context) (v notificationtime.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationTimeMutation) ResetType() {
	m._type = nil
}

// SetSendMinute sets the "send_minute" field.
func (m *NotificationTimeMutation) SetSendMinute(i int) {
	m.send_minute = &i
	m.addsend_minute = nil
}

// SendMinute returns the value of the "send_minute" field in the mutation.
func (m *NotificationTimeMutation) SendMinute() (r int, exists bool) {
	v := m.send_minute
	if v == nil {
		return
	}
	return *v, true
}

// OldSendMinute returns the old "send_minute" field's value of the NotificationTime entity.
// If the NotificationTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTimeMutation) OldSendMinute(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendMinute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendMinute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendMinute: %w", err)
	}
	return oldValue.SendMinute, nil
}

// AddSendMinute adds i to the "send_minute" field.
func (m *NotificationTimeMutation) AddSendMinute(i int) {
	if m.addsend_minute != nil {
		*m.addsend_minute += i
	} else {
		m.addsend_minute = &i
	}
}

// AddedSendMinute returns the value that was added to the "send_minute" field in this mutation.
func (m *NotificationTimeMutation) AddedSendMinute() (r int, exists bool) {
	v := m.addsend_minute
	if v == nil {
		return
	}
	return *v, true
}

// ResetSendMinute resets all changes to the "send_minute" field.
func (m *NotificationTimeMutation) ResetSendMinute() {
	m.send_minute = nil
	m.addsend_minute = nil
}

// SetProfileID sets the "profile_id" field.
func (m *NotificationTimeMutation) SetProfileID(i int) {
	m.profile = &i
}

// ProfileID returns the value of the "profile_id" field in the mutation.
func (m *NotificationTimeMutation) ProfileID() (r int, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileID returns the old "profile_id" field's value of the NotificationTime entity.
// If the NotificationTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationTimeMutation) OldProfileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileID: %w", err)
	}
	return oldValue.ProfileID, nil
}

// ResetProfileID resets all changes to the "profile_id" field.
func (m *NotificationTimeMutation) ResetProfileID() {
	m.profile = nil
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *NotificationTimeMutation) ClearProfile() {
	m.clearedprofile = true
	m.clearedFields[notificationtime.FieldProfileID] = struct{}{}
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *NotificationTimeMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *NotificationTimeMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *NotificationTimeMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the NotificationTimeMutation builder.
func (m *NotificationTimeMutation) Where(ps ...predicate.NotificationTime) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationTimeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationTimeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationTime, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationTimeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationTimeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationTime).
func (m *NotificationTimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationTimeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, notificationtime.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationtime.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, notificationtime.FieldType)
	}
	if m.send_minute != nil {
		fields = append(fields, notificationtime.FieldSendMinute)
	}
	if m.profile != nil {
		fields = append(fields, notificationtime.FieldProfileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationTimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationtime.FieldCreatedAt:
		return m.CreatedAt()
	case notificationtime.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationtime.FieldType:
		return m.GetType()
	case notificationtime.FieldSendMinute:
		return m.SendMinute()
	case notificationtime.FieldProfileID:
		return m.ProfileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationTimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationtime.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationtime.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationtime.FieldType:
		return m.OldType(ctx)
	case notificationtime.FieldSendMinute:
		return m.OldSendMinute(ctx)
	case notificationtime.FieldProfileID:
		return m.OldProfileID(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationTime field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationTimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationtime.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationtime.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationtime.FieldType:
		v, ok := value.(notificationtime.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationtime.FieldSendMinute:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendMinute(v)
		return nil
	case notificationtime.FieldProfileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileID(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationTime field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationTimeMutation) AddedFields() []string {
	var fields []string
	if m.addsend_minute != nil {
		fields = append(fields, notificationtime.FieldSendMinute)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationTimeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notificationtime.FieldSendMinute:
		return m.AddedSendMinute()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationTimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notificationtime.FieldSendMinute:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSendMinute(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationTime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationTimeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationTimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationTimeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotificationTime nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationTimeMutation) ResetField(name string) error {
	switch name {
	case notificationtime.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationtime.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationtime.FieldType:
		m.ResetType()
		return nil
	case notificationtime.FieldSendMinute:
		m.ResetSendMinute()
		return nil
	case notificationtime.FieldProfileID:
		m.ResetProfileID()
		return nil
	}
	return fmt.Errorf("unknown NotificationTime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationTimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.profile != nil {
		edges = append(edges, notificationtime.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationTimeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationtime.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationTimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationTimeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationTimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprofile {
		edges = append(edges, notificationtime.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationTimeMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationtime.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationTimeMutation) ClearEdge(name string) error {
	switch name {
	case notificationtime.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown NotificationTime unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationTimeMutation) ResetEdge(name string) error {
	switch name {
	case notificationtime.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown NotificationTime edge %s", name)
}

// PasswordTokenMutation represents an operation that mutates the PasswordToken nodes in the graph.
type PasswordTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	hash          *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*PasswordToken, error)
	predicates    []predicate.PasswordToken
}

var _ ent.Mutation = (*PasswordTokenMutation)(nil)

// passwordtokenOption allows management of the mutation configuration using functional options.
type passwordtokenOption func(*PasswordTokenMutation)

// newPasswordTokenMutation creates new mutation for the PasswordToken entity.
func newPasswordTokenMutation(c config, op Op, opts ...passwordtokenOption) *PasswordTokenMutation {
	m := &PasswordTokenMutation{
		config:        c,
		op:            op,
		typ:           TypePasswordToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordTokenID sets the ID field of the mutation.
func withPasswordTokenID(id int) passwordtokenOption {
	return func(m *PasswordTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *PasswordToken
		)
		m.oldValue = func(ctx context.Context) (*PasswordToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PasswordToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasswordToken sets the old PasswordToken of the mutation.
func withPasswordToken(node *PasswordToken) passwordtokenOption {
	return func(m *PasswordTokenMutation) {
		m.oldValue = func(context.Context) (*PasswordToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PasswordToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHash sets the "hash" field.
func (m *PasswordTokenMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *PasswordTokenMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the PasswordToken entity.
// If the PasswordToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordTokenMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *PasswordTokenMutation) ResetHash() {
	m.hash = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PasswordTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasswordTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PasswordToken entity.
// If the PasswordToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasswordTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PasswordTokenMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasswordTokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasswordTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PasswordTokenMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasswordTokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasswordTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasswordTokenMutation builder.
func (m *PasswordTokenMutation) Where(ps ...predicate.PasswordToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PasswordToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PasswordToken).
func (m *PasswordTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordTokenMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.hash != nil {
		fields = append(fields, passwordtoken.FieldHash)
	}
	if m.created_at != nil {
		fields = append(fields, passwordtoken.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passwordtoken.FieldHash:
		return m.Hash()
	case passwordtoken.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passwordtoken.FieldHash:
		return m.OldHash(ctx)
	case passwordtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PasswordToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passwordtoken.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case passwordtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PasswordToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PasswordToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PasswordToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordTokenMutation) ResetField(name string) error {
	switch name {
	case passwordtoken.FieldHash:
		m.ResetHash()
		return nil
	case passwordtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PasswordToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, passwordtoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passwordtoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, passwordtoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case passwordtoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordTokenMutation) ClearEdge(name string) error {
	switch name {
	case passwordtoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordTokenMutation) ResetEdge(name string) error {
	switch name {
	case passwordtoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordToken edge %s", name)
}

// PhoneVerificationCodeMutation represents an operation that mutates the PhoneVerificationCode nodes in the graph.
type PhoneVerificationCodeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	code           *string
	clearedFields  map[string]struct{}
	profile        *int
	clearedprofile bool
	done           bool
	oldValue       func(context.Context) (*PhoneVerificationCode, error)
	predicates     []predicate.PhoneVerificationCode
}

var _ ent.Mutation = (*PhoneVerificationCodeMutation)(nil)

// phoneverificationcodeOption allows management of the mutation configuration using functional options.
type phoneverificationcodeOption func(*PhoneVerificationCodeMutation)

// newPhoneVerificationCodeMutation creates new mutation for the PhoneVerificationCode entity.
func newPhoneVerificationCodeMutation(c config, op Op, opts ...phoneverificationcodeOption) *PhoneVerificationCodeMutation {
	m := &PhoneVerificationCodeMutation{
		config:        c,
		op:            op,
		typ:           TypePhoneVerificationCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPhoneVerificationCodeID sets the ID field of the mutation.
func withPhoneVerificationCodeID(id int) phoneverificationcodeOption {
	return func(m *PhoneVerificationCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *PhoneVerificationCode
		)
		m.oldValue = func(ctx context.Context) (*PhoneVerificationCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PhoneVerificationCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPhoneVerificationCode sets the old PhoneVerificationCode of the mutation.
func withPhoneVerificationCode(node *PhoneVerificationCode) phoneverificationcodeOption {
	return func(m *PhoneVerificationCodeMutation) {
		m.oldValue = func(context.Context) (*PhoneVerificationCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PhoneVerificationCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PhoneVerificationCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PhoneVerificationCodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PhoneVerificationCodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PhoneVerificationCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PhoneVerificationCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PhoneVerificationCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PhoneVerificationCode entity.
// If the PhoneVerificationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneVerificationCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PhoneVerificationCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PhoneVerificationCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PhoneVerificationCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PhoneVerificationCode entity.
// If the PhoneVerificationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneVerificationCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PhoneVerificationCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCode sets the "code" field.
func (m *PhoneVerificationCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *PhoneVerificationCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the PhoneVerificationCode entity.
// If the PhoneVerificationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneVerificationCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *PhoneVerificationCodeMutation) ResetCode() {
	m.code = nil
}

// SetProfileID sets the "profile_id" field.
func (m *PhoneVerificationCodeMutation) SetProfileID(i int) {
	m.profile = &i
}

// ProfileID returns the value of the "profile_id" field in the mutation.
func (m *PhoneVerificationCodeMutation) ProfileID() (r int, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileID returns the old "profile_id" field's value of the PhoneVerificationCode entity.
// If the PhoneVerificationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneVerificationCodeMutation) OldProfileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileID: %w", err)
	}
	return oldValue.ProfileID, nil
}

// ResetProfileID resets all changes to the "profile_id" field.
func (m *PhoneVerificationCodeMutation) ResetProfileID() {
	m.profile = nil
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *PhoneVerificationCodeMutation) ClearProfile() {
	m.clearedprofile = true
	m.clearedFields[phoneverificationcode.FieldProfileID] = struct{}{}
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *PhoneVerificationCodeMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *PhoneVerificationCodeMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *PhoneVerificationCodeMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the PhoneVerificationCodeMutation builder.
func (m *PhoneVerificationCodeMutation) Where(ps ...predicate.PhoneVerificationCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PhoneVerificationCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PhoneVerificationCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PhoneVerificationCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PhoneVerificationCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PhoneVerificationCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PhoneVerificationCode).
func (m *PhoneVerificationCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PhoneVerificationCodeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, phoneverificationcode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, phoneverificationcode.FieldUpdatedAt)
	}
	if m.code != nil {
		fields = append(fields, phoneverificationcode.FieldCode)
	}
	if m.profile != nil {
		fields = append(fields, phoneverificationcode.FieldProfileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PhoneVerificationCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case phoneverificationcode.FieldCreatedAt:
		return m.CreatedAt()
	case phoneverificationcode.FieldUpdatedAt:
		return m.UpdatedAt()
	case phoneverificationcode.FieldCode:
		return m.Code()
	case phoneverificationcode.FieldProfileID:
		return m.ProfileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PhoneVerificationCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case phoneverificationcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case phoneverificationcode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case phoneverificationcode.FieldCode:
		return m.OldCode(ctx)
	case phoneverificationcode.FieldProfileID:
		return m.OldProfileID(ctx)
	}
	return nil, fmt.Errorf("unknown PhoneVerificationCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhoneVerificationCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case phoneverificationcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case phoneverificationcode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case phoneverificationcode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case phoneverificationcode.FieldProfileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileID(v)
		return nil
	}
	return fmt.Errorf("unknown PhoneVerificationCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PhoneVerificationCodeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PhoneVerificationCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhoneVerificationCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PhoneVerificationCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PhoneVerificationCodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PhoneVerificationCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PhoneVerificationCodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PhoneVerificationCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PhoneVerificationCodeMutation) ResetField(name string) error {
	switch name {
	case phoneverificationcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case phoneverificationcode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case phoneverificationcode.FieldCode:
		m.ResetCode()
		return nil
	case phoneverificationcode.FieldProfileID:
		m.ResetProfileID()
		return nil
	}
	return fmt.Errorf("unknown PhoneVerificationCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PhoneVerificationCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.profile != nil {
		edges = append(edges, phoneverificationcode.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PhoneVerificationCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case phoneverificationcode.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PhoneVerificationCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PhoneVerificationCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PhoneVerificationCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprofile {
		edges = append(edges, phoneverificationcode.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PhoneVerificationCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case phoneverificationcode.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PhoneVerificationCodeMutation) ClearEdge(name string) error {
	switch name {
	case phoneverificationcode.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown PhoneVerificationCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PhoneVerificationCodeMutation) ResetEdge(name string) error {
	switch name {
	case phoneverificationcode.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown PhoneVerificationCode edge %s", name)
}

// ProfileMutation represents an operation that mutates the Profile nodes in the graph.
type ProfileMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	created_at                      *time.Time
	updated_at                      *time.Time
	bio                             *string
	birthdate                       *time.Time
	age                             *int
	addage                          *int
	fully_onboarded                 *bool
	phone_number_e164               *string
	country_code                    *string
	phone_verified                  *bool
	stripe_id                       *string
	clearedFields                   map[string]struct{}
	friends                         map[int]struct{}
	removedfriends                  map[int]struct{}
	clearedfriends                  bool
	photos                          map[int]struct{}
	removedphotos                   map[int]struct{}
	clearedphotos                   bool
	profile_image                   *int
	clearedprofile_image            bool
	notifications                   map[int]struct{}
	removednotifications            map[int]struct{}
	clearednotifications            bool
	invitations                     map[int]struct{}
	removedinvitations              map[int]struct{}
	clearedinvitations              bool
	fcm_push_subscriptions          map[int]struct{}
	removedfcm_push_subscriptions   map[int]struct{}
	clearedfcm_push_subscriptions   bool
	pwa_push_subscriptions          map[int]struct{}
	removedpwa_push_subscriptions   map[int]struct{}
	clearedpwa_push_subscriptions   bool
	notification_permissions        map[int]struct{}
	removednotification_permissions map[int]struct{}
	clearednotification_permissions bool
	notification_times              map[int]struct{}
	removednotification_times       map[int]struct{}
	clearednotification_times       bool
	phone_verification_code         map[int]struct{}
	removedphone_verification_code  map[int]struct{}
	clearedphone_verification_code  bool
	sent_emails                     map[int]struct{}
	removedsent_emails              map[int]struct{}
	clearedsent_emails              bool
	user                            *int
	cleareduser                     bool
	subscription                    map[int]struct{}
	removedsubscription             map[int]struct{}
	clearedsubscription             bool
	done                            bool
	oldValue                        func(context.Context) (*Profile, error)
	predicates                      []predicate.Profile
}

var _ ent.Mutation = (*ProfileMutation)(nil)

// profileOption allows management of the mutation configuration using functional options.
type profileOption func(*ProfileMutation)

// newProfileMutation creates new mutation for the Profile entity.
func newProfileMutation(c config, op Op, opts ...profileOption) *ProfileMutation {
	m := &ProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileID sets the ID field of the mutation.
func withProfileID(id int) profileOption {
	return func(m *ProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *Profile
		)
		m.oldValue = func(ctx context.Context) (*Profile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfile sets the old Profile of the mutation.
func withProfile(node *Profile) profileOption {
	return func(m *ProfileMutation) {
		m.oldValue = func(context.Context) (*Profile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Profile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBio sets the "bio" field.
func (m *ProfileMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *ProfileMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *ProfileMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[profile.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *ProfileMutation) BioCleared() bool {
	_, ok := m.clearedFields[profile.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *ProfileMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, profile.FieldBio)
}

// SetBirthdate sets the "birthdate" field.
func (m *ProfileMutation) SetBirthdate(t time.Time) {
	m.birthdate = &t
}

// Birthdate returns the value of the "birthdate" field in the mutation.
func (m *ProfileMutation) Birthdate() (r time.Time, exists bool) {
	v := m.birthdate
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdate returns the old "birthdate" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldBirthdate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdate: %w", err)
	}
	return oldValue.Birthdate, nil
}

// ClearBirthdate clears the value of the "birthdate" field.
func (m *ProfileMutation) ClearBirthdate() {
	m.birthdate = nil
	m.clearedFields[profile.FieldBirthdate] = struct{}{}
}

// BirthdateCleared returns if the "birthdate" field was cleared in this mutation.
func (m *ProfileMutation) BirthdateCleared() bool {
	_, ok := m.clearedFields[profile.FieldBirthdate]
	return ok
}

// ResetBirthdate resets all changes to the "birthdate" field.
func (m *ProfileMutation) ResetBirthdate() {
	m.birthdate = nil
	delete(m.clearedFields, profile.FieldBirthdate)
}

// SetAge sets the "age" field.
func (m *ProfileMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *ProfileMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *ProfileMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *ProfileMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ClearAge clears the value of the "age" field.
func (m *ProfileMutation) ClearAge() {
	m.age = nil
	m.addage = nil
	m.clearedFields[profile.FieldAge] = struct{}{}
}

// AgeCleared returns if the "age" field was cleared in this mutation.
func (m *ProfileMutation) AgeCleared() bool {
	_, ok := m.clearedFields[profile.FieldAge]
	return ok
}

// ResetAge resets all changes to the "age" field.
func (m *ProfileMutation) ResetAge() {
	m.age = nil
	m.addage = nil
	delete(m.clearedFields, profile.FieldAge)
}

// SetFullyOnboarded sets the "fully_onboarded" field.
func (m *ProfileMutation) SetFullyOnboarded(b bool) {
	m.fully_onboarded = &b
}

// FullyOnboarded returns the value of the "fully_onboarded" field in the mutation.
func (m *ProfileMutation) FullyOnboarded() (r bool, exists bool) {
	v := m.fully_onboarded
	if v == nil {
		return
	}
	return *v, true
}

// OldFullyOnboarded returns the old "fully_onboarded" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldFullyOnboarded(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullyOnboarded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullyOnboarded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullyOnboarded: %w", err)
	}
	return oldValue.FullyOnboarded, nil
}

// ResetFullyOnboarded resets all changes to the "fully_onboarded" field.
func (m *ProfileMutation) ResetFullyOnboarded() {
	m.fully_onboarded = nil
}

// SetPhoneNumberE164 sets the "phone_number_e164" field.
func (m *ProfileMutation) SetPhoneNumberE164(s string) {
	m.phone_number_e164 = &s
}

// PhoneNumberE164 returns the value of the "phone_number_e164" field in the mutation.
func (m *ProfileMutation) PhoneNumberE164() (r string, exists bool) {
	v := m.phone_number_e164
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumberE164 returns the old "phone_number_e164" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldPhoneNumberE164(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumberE164 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumberE164 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumberE164: %w", err)
	}
	return oldValue.PhoneNumberE164, nil
}

// ClearPhoneNumberE164 clears the value of the "phone_number_e164" field.
func (m *ProfileMutation) ClearPhoneNumberE164() {
	m.phone_number_e164 = nil
	m.clearedFields[profile.FieldPhoneNumberE164] = struct{}{}
}

// PhoneNumberE164Cleared returns if the "phone_number_e164" field was cleared in this mutation.
func (m *ProfileMutation) PhoneNumberE164Cleared() bool {
	_, ok := m.clearedFields[profile.FieldPhoneNumberE164]
	return ok
}

// ResetPhoneNumberE164 resets all changes to the "phone_number_e164" field.
func (m *ProfileMutation) ResetPhoneNumberE164() {
	m.phone_number_e164 = nil
	delete(m.clearedFields, profile.FieldPhoneNumberE164)
}

// SetCountryCode sets the "country_code" field.
func (m *ProfileMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *ProfileMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ClearCountryCode clears the value of the "country_code" field.
func (m *ProfileMutation) ClearCountryCode() {
	m.country_code = nil
	m.clearedFields[profile.FieldCountryCode] = struct{}{}
}

// CountryCodeCleared returns if the "country_code" field was cleared in this mutation.
func (m *ProfileMutation) CountryCodeCleared() bool {
	_, ok := m.clearedFields[profile.FieldCountryCode]
	return ok
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *ProfileMutation) ResetCountryCode() {
	m.country_code = nil
	delete(m.clearedFields, profile.FieldCountryCode)
}

// SetPhoneVerified sets the "phone_verified" field.
func (m *ProfileMutation) SetPhoneVerified(b bool) {
	m.phone_verified = &b
}

// PhoneVerified returns the value of the "phone_verified" field in the mutation.
func (m *ProfileMutation) PhoneVerified() (r bool, exists bool) {
	v := m.phone_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneVerified returns the old "phone_verified" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldPhoneVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneVerified: %w", err)
	}
	return oldValue.PhoneVerified, nil
}

// ClearPhoneVerified clears the value of the "phone_verified" field.
func (m *ProfileMutation) ClearPhoneVerified() {
	m.phone_verified = nil
	m.clearedFields[profile.FieldPhoneVerified] = struct{}{}
}

// PhoneVerifiedCleared returns if the "phone_verified" field was cleared in this mutation.
func (m *ProfileMutation) PhoneVerifiedCleared() bool {
	_, ok := m.clearedFields[profile.FieldPhoneVerified]
	return ok
}

// ResetPhoneVerified resets all changes to the "phone_verified" field.
func (m *ProfileMutation) ResetPhoneVerified() {
	m.phone_verified = nil
	delete(m.clearedFields, profile.FieldPhoneVerified)
}

// SetStripeID sets the "stripe_id" field.
func (m *ProfileMutation) SetStripeID(s string) {
	m.stripe_id = &s
}

// StripeID returns the value of the "stripe_id" field in the mutation.
func (m *ProfileMutation) StripeID() (r string, exists bool) {
	v := m.stripe_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeID returns the old "stripe_id" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldStripeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeID: %w", err)
	}
	return oldValue.StripeID, nil
}

// ClearStripeID clears the value of the "stripe_id" field.
func (m *ProfileMutation) ClearStripeID() {
	m.stripe_id = nil
	m.clearedFields[profile.FieldStripeID] = struct{}{}
}

// StripeIDCleared returns if the "stripe_id" field was cleared in this mutation.
func (m *ProfileMutation) StripeIDCleared() bool {
	_, ok := m.clearedFields[profile.FieldStripeID]
	return ok
}

// ResetStripeID resets all changes to the "stripe_id" field.
func (m *ProfileMutation) ResetStripeID() {
	m.stripe_id = nil
	delete(m.clearedFields, profile.FieldStripeID)
}

// AddFriendIDs adds the "friends" edge to the Profile entity by ids.
func (m *ProfileMutation) AddFriendIDs(ids ...int) {
	if m.friends == nil {
		m.friends = make(map[int]struct{})
	}
	for i := range ids {
		m.friends[ids[i]] = struct{}{}
	}
}

// ClearFriends clears the "friends" edge to the Profile entity.
func (m *ProfileMutation) ClearFriends() {
	m.clearedfriends = true
}

// FriendsCleared reports if the "friends" edge to the Profile entity was cleared.
func (m *ProfileMutation) FriendsCleared() bool {
	return m.clearedfriends
}

// RemoveFriendIDs removes the "friends" edge to the Profile entity by IDs.
func (m *ProfileMutation) RemoveFriendIDs(ids ...int) {
	if m.removedfriends == nil {
		m.removedfriends = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.friends, ids[i])
		m.removedfriends[ids[i]] = struct{}{}
	}
}

// RemovedFriends returns the removed IDs of the "friends" edge to the Profile entity.
func (m *ProfileMutation) RemovedFriendsIDs() (ids []int) {
	for id := range m.removedfriends {
		ids = append(ids, id)
	}
	return
}

// FriendsIDs returns the "friends" edge IDs in the mutation.
func (m *ProfileMutation) FriendsIDs() (ids []int) {
	for id := range m.friends {
		ids = append(ids, id)
	}
	return
}

// ResetFriends resets all changes to the "friends" edge.
func (m *ProfileMutation) ResetFriends() {
	m.friends = nil
	m.clearedfriends = false
	m.removedfriends = nil
}

// AddPhotoIDs adds the "photos" edge to the Image entity by ids.
func (m *ProfileMutation) AddPhotoIDs(ids ...int) {
	if m.photos == nil {
		m.photos = make(map[int]struct{})
	}
	for i := range ids {
		m.photos[ids[i]] = struct{}{}
	}
}

// ClearPhotos clears the "photos" edge to the Image entity.
func (m *ProfileMutation) ClearPhotos() {
	m.clearedphotos = true
}

// PhotosCleared reports if the "photos" edge to the Image entity was cleared.
func (m *ProfileMutation) PhotosCleared() bool {
	return m.clearedphotos
}

// RemovePhotoIDs removes the "photos" edge to the Image entity by IDs.
func (m *ProfileMutation) RemovePhotoIDs(ids ...int) {
	if m.removedphotos == nil {
		m.removedphotos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.photos, ids[i])
		m.removedphotos[ids[i]] = struct{}{}
	}
}

// RemovedPhotos returns the removed IDs of the "photos" edge to the Image entity.
func (m *ProfileMutation) RemovedPhotosIDs() (ids []int) {
	for id := range m.removedphotos {
		ids = append(ids, id)
	}
	return
}

// PhotosIDs returns the "photos" edge IDs in the mutation.
func (m *ProfileMutation) PhotosIDs() (ids []int) {
	for id := range m.photos {
		ids = append(ids, id)
	}
	return
}

// ResetPhotos resets all changes to the "photos" edge.
func (m *ProfileMutation) ResetPhotos() {
	m.photos = nil
	m.clearedphotos = false
	m.removedphotos = nil
}

// SetProfileImageID sets the "profile_image" edge to the Image entity by id.
func (m *ProfileMutation) SetProfileImageID(id int) {
	m.profile_image = &id
}

// ClearProfileImage clears the "profile_image" edge to the Image entity.
func (m *ProfileMutation) ClearProfileImage() {
	m.clearedprofile_image = true
}

// ProfileImageCleared reports if the "profile_image" edge to the Image entity was cleared.
func (m *ProfileMutation) ProfileImageCleared() bool {
	return m.clearedprofile_image
}

// ProfileImageID returns the "profile_image" edge ID in the mutation.
func (m *ProfileMutation) ProfileImageID() (id int, exists bool) {
	if m.profile_image != nil {
		return *m.profile_image, true
	}
	return
}

// ProfileImageIDs returns the "profile_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileImageID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) ProfileImageIDs() (ids []int) {
	if id := m.profile_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfileImage resets all changes to the "profile_image" edge.
func (m *ProfileMutation) ResetProfileImage() {
	m.profile_image = nil
	m.clearedprofile_image = false
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *ProfileMutation) AddNotificationIDs(ids ...int) {
	if m.notifications == nil {
		m.notifications = make(map[int]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *ProfileMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *ProfileMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *ProfileMutation) RemoveNotificationIDs(ids ...int) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *ProfileMutation) RemovedNotificationsIDs() (ids []int) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *ProfileMutation) NotificationsIDs() (ids []int) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *ProfileMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// AddInvitationIDs adds the "invitations" edge to the Invitation entity by ids.
func (m *ProfileMutation) AddInvitationIDs(ids ...int) {
	if m.invitations == nil {
		m.invitations = make(map[int]struct{})
	}
	for i := range ids {
		m.invitations[ids[i]] = struct{}{}
	}
}

// ClearInvitations clears the "invitations" edge to the Invitation entity.
func (m *ProfileMutation) ClearInvitations() {
	m.clearedinvitations = true
}

// InvitationsCleared reports if the "invitations" edge to the Invitation entity was cleared.
func (m *ProfileMutation) InvitationsCleared() bool {
	return m.clearedinvitations
}

// RemoveInvitationIDs removes the "invitations" edge to the Invitation entity by IDs.
func (m *ProfileMutation) RemoveInvitationIDs(ids ...int) {
	if m.removedinvitations == nil {
		m.removedinvitations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.invitations, ids[i])
		m.removedinvitations[ids[i]] = struct{}{}
	}
}

// RemovedInvitations returns the removed IDs of the "invitations" edge to the Invitation entity.
func (m *ProfileMutation) RemovedInvitationsIDs() (ids []int) {
	for id := range m.removedinvitations {
		ids = append(ids, id)
	}
	return
}

// InvitationsIDs returns the "invitations" edge IDs in the mutation.
func (m *ProfileMutation) InvitationsIDs() (ids []int) {
	for id := range m.invitations {
		ids = append(ids, id)
	}
	return
}

// ResetInvitations resets all changes to the "invitations" edge.
func (m *ProfileMutation) ResetInvitations() {
	m.invitations = nil
	m.clearedinvitations = false
	m.removedinvitations = nil
}

// AddFcmPushSubscriptionIDs adds the "fcm_push_subscriptions" edge to the FCMSubscriptions entity by ids.
func (m *ProfileMutation) AddFcmPushSubscriptionIDs(ids ...int) {
	if m.fcm_push_subscriptions == nil {
		m.fcm_push_subscriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.fcm_push_subscriptions[ids[i]] = struct{}{}
	}
}

// ClearFcmPushSubscriptions clears the "fcm_push_subscriptions" edge to the FCMSubscriptions entity.
func (m *ProfileMutation) ClearFcmPushSubscriptions() {
	m.clearedfcm_push_subscriptions = true
}

// FcmPushSubscriptionsCleared reports if the "fcm_push_subscriptions" edge to the FCMSubscriptions entity was cleared.
func (m *ProfileMutation) FcmPushSubscriptionsCleared() bool {
	return m.clearedfcm_push_subscriptions
}

// RemoveFcmPushSubscriptionIDs removes the "fcm_push_subscriptions" edge to the FCMSubscriptions entity by IDs.
func (m *ProfileMutation) RemoveFcmPushSubscriptionIDs(ids ...int) {
	if m.removedfcm_push_subscriptions == nil {
		m.removedfcm_push_subscriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fcm_push_subscriptions, ids[i])
		m.removedfcm_push_subscriptions[ids[i]] = struct{}{}
	}
}

// RemovedFcmPushSubscriptions returns the removed IDs of the "fcm_push_subscriptions" edge to the FCMSubscriptions entity.
func (m *ProfileMutation) RemovedFcmPushSubscriptionsIDs() (ids []int) {
	for id := range m.removedfcm_push_subscriptions {
		ids = append(ids, id)
	}
	return
}

// FcmPushSubscriptionsIDs returns the "fcm_push_subscriptions" edge IDs in the mutation.
func (m *ProfileMutation) FcmPushSubscriptionsIDs() (ids []int) {
	for id := range m.fcm_push_subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetFcmPushSubscriptions resets all changes to the "fcm_push_subscriptions" edge.
func (m *ProfileMutation) ResetFcmPushSubscriptions() {
	m.fcm_push_subscriptions = nil
	m.clearedfcm_push_subscriptions = false
	m.removedfcm_push_subscriptions = nil
}

// AddPwaPushSubscriptionIDs adds the "pwa_push_subscriptions" edge to the PwaPushSubscription entity by ids.
func (m *ProfileMutation) AddPwaPushSubscriptionIDs(ids ...int) {
	if m.pwa_push_subscriptions == nil {
		m.pwa_push_subscriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.pwa_push_subscriptions[ids[i]] = struct{}{}
	}
}

// ClearPwaPushSubscriptions clears the "pwa_push_subscriptions" edge to the PwaPushSubscription entity.
func (m *ProfileMutation) ClearPwaPushSubscriptions() {
	m.clearedpwa_push_subscriptions = true
}

// PwaPushSubscriptionsCleared reports if the "pwa_push_subscriptions" edge to the PwaPushSubscription entity was cleared.
func (m *ProfileMutation) PwaPushSubscriptionsCleared() bool {
	return m.clearedpwa_push_subscriptions
}

// RemovePwaPushSubscriptionIDs removes the "pwa_push_subscriptions" edge to the PwaPushSubscription entity by IDs.
func (m *ProfileMutation) RemovePwaPushSubscriptionIDs(ids ...int) {
	if m.removedpwa_push_subscriptions == nil {
		m.removedpwa_push_subscriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pwa_push_subscriptions, ids[i])
		m.removedpwa_push_subscriptions[ids[i]] = struct{}{}
	}
}

// RemovedPwaPushSubscriptions returns the removed IDs of the "pwa_push_subscriptions" edge to the PwaPushSubscription entity.
func (m *ProfileMutation) RemovedPwaPushSubscriptionsIDs() (ids []int) {
	for id := range m.removedpwa_push_subscriptions {
		ids = append(ids, id)
	}
	return
}

// PwaPushSubscriptionsIDs returns the "pwa_push_subscriptions" edge IDs in the mutation.
func (m *ProfileMutation) PwaPushSubscriptionsIDs() (ids []int) {
	for id := range m.pwa_push_subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetPwaPushSubscriptions resets all changes to the "pwa_push_subscriptions" edge.
func (m *ProfileMutation) ResetPwaPushSubscriptions() {
	m.pwa_push_subscriptions = nil
	m.clearedpwa_push_subscriptions = false
	m.removedpwa_push_subscriptions = nil
}

// AddNotificationPermissionIDs adds the "notification_permissions" edge to the NotificationPermission entity by ids.
func (m *ProfileMutation) AddNotificationPermissionIDs(ids ...int) {
	if m.notification_permissions == nil {
		m.notification_permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.notification_permissions[ids[i]] = struct{}{}
	}
}

// ClearNotificationPermissions clears the "notification_permissions" edge to the NotificationPermission entity.
func (m *ProfileMutation) ClearNotificationPermissions() {
	m.clearednotification_permissions = true
}

// NotificationPermissionsCleared reports if the "notification_permissions" edge to the NotificationPermission entity was cleared.
func (m *ProfileMutation) NotificationPermissionsCleared() bool {
	return m.clearednotification_permissions
}

// RemoveNotificationPermissionIDs removes the "notification_permissions" edge to the NotificationPermission entity by IDs.
func (m *ProfileMutation) RemoveNotificationPermissionIDs(ids ...int) {
	if m.removednotification_permissions == nil {
		m.removednotification_permissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notification_permissions, ids[i])
		m.removednotification_permissions[ids[i]] = struct{}{}
	}
}

// RemovedNotificationPermissions returns the removed IDs of the "notification_permissions" edge to the NotificationPermission entity.
func (m *ProfileMutation) RemovedNotificationPermissionsIDs() (ids []int) {
	for id := range m.removednotification_permissions {
		ids = append(ids, id)
	}
	return
}

// NotificationPermissionsIDs returns the "notification_permissions" edge IDs in the mutation.
func (m *ProfileMutation) NotificationPermissionsIDs() (ids []int) {
	for id := range m.notification_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationPermissions resets all changes to the "notification_permissions" edge.
func (m *ProfileMutation) ResetNotificationPermissions() {
	m.notification_permissions = nil
	m.clearednotification_permissions = false
	m.removednotification_permissions = nil
}

// AddNotificationTimeIDs adds the "notification_times" edge to the NotificationTime entity by ids.
func (m *ProfileMutation) AddNotificationTimeIDs(ids ...int) {
	if m.notification_times == nil {
		m.notification_times = make(map[int]struct{})
	}
	for i := range ids {
		m.notification_times[ids[i]] = struct{}{}
	}
}

// ClearNotificationTimes clears the "notification_times" edge to the NotificationTime entity.
func (m *ProfileMutation) ClearNotificationTimes() {
	m.clearednotification_times = true
}

// NotificationTimesCleared reports if the "notification_times" edge to the NotificationTime entity was cleared.
func (m *ProfileMutation) NotificationTimesCleared() bool {
	return m.clearednotification_times
}

// RemoveNotificationTimeIDs removes the "notification_times" edge to the NotificationTime entity by IDs.
func (m *ProfileMutation) RemoveNotificationTimeIDs(ids ...int) {
	if m.removednotification_times == nil {
		m.removednotification_times = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notification_times, ids[i])
		m.removednotification_times[ids[i]] = struct{}{}
	}
}

// RemovedNotificationTimes returns the removed IDs of the "notification_times" edge to the NotificationTime entity.
func (m *ProfileMutation) RemovedNotificationTimesIDs() (ids []int) {
	for id := range m.removednotification_times {
		ids = append(ids, id)
	}
	return
}

// NotificationTimesIDs returns the "notification_times" edge IDs in the mutation.
func (m *ProfileMutation) NotificationTimesIDs() (ids []int) {
	for id := range m.notification_times {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationTimes resets all changes to the "notification_times" edge.
func (m *ProfileMutation) ResetNotificationTimes() {
	m.notification_times = nil
	m.clearednotification_times = false
	m.removednotification_times = nil
}

// AddPhoneVerificationCodeIDs adds the "phone_verification_code" edge to the PhoneVerificationCode entity by ids.
func (m *ProfileMutation) AddPhoneVerificationCodeIDs(ids ...int) {
	if m.phone_verification_code == nil {
		m.phone_verification_code = make(map[int]struct{})
	}
	for i := range ids {
		m.phone_verification_code[ids[i]] = struct{}{}
	}
}

// ClearPhoneVerificationCode clears the "phone_verification_code" edge to the PhoneVerificationCode entity.
func (m *ProfileMutation) ClearPhoneVerificationCode() {
	m.clearedphone_verification_code = true
}

// PhoneVerificationCodeCleared reports if the "phone_verification_code" edge to the PhoneVerificationCode entity was cleared.
func (m *ProfileMutation) PhoneVerificationCodeCleared() bool {
	return m.clearedphone_verification_code
}

// RemovePhoneVerificationCodeIDs removes the "phone_verification_code" edge to the PhoneVerificationCode entity by IDs.
func (m *ProfileMutation) RemovePhoneVerificationCodeIDs(ids ...int) {
	if m.removedphone_verification_code == nil {
		m.removedphone_verification_code = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.phone_verification_code, ids[i])
		m.removedphone_verification_code[ids[i]] = struct{}{}
	}
}

// RemovedPhoneVerificationCode returns the removed IDs of the "phone_verification_code" edge to the PhoneVerificationCode entity.
func (m *ProfileMutation) RemovedPhoneVerificationCodeIDs() (ids []int) {
	for id := range m.removedphone_verification_code {
		ids = append(ids, id)
	}
	return
}

// PhoneVerificationCodeIDs returns the "phone_verification_code" edge IDs in the mutation.
func (m *ProfileMutation) PhoneVerificationCodeIDs() (ids []int) {
	for id := range m.phone_verification_code {
		ids = append(ids, id)
	}
	return
}

// ResetPhoneVerificationCode resets all changes to the "phone_verification_code" edge.
func (m *ProfileMutation) ResetPhoneVerificationCode() {
	m.phone_verification_code = nil
	m.clearedphone_verification_code = false
	m.removedphone_verification_code = nil
}

// AddSentEmailIDs adds the "sent_emails" edge to the SentEmail entity by ids.
func (m *ProfileMutation) AddSentEmailIDs(ids ...int) {
	if m.sent_emails == nil {
		m.sent_emails = make(map[int]struct{})
	}
	for i := range ids {
		m.sent_emails[ids[i]] = struct{}{}
	}
}

// ClearSentEmails clears the "sent_emails" edge to the SentEmail entity.
func (m *ProfileMutation) ClearSentEmails() {
	m.clearedsent_emails = true
}

// SentEmailsCleared reports if the "sent_emails" edge to the SentEmail entity was cleared.
func (m *ProfileMutation) SentEmailsCleared() bool {
	return m.clearedsent_emails
}

// RemoveSentEmailIDs removes the "sent_emails" edge to the SentEmail entity by IDs.
func (m *ProfileMutation) RemoveSentEmailIDs(ids ...int) {
	if m.removedsent_emails == nil {
		m.removedsent_emails = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sent_emails, ids[i])
		m.removedsent_emails[ids[i]] = struct{}{}
	}
}

// RemovedSentEmails returns the removed IDs of the "sent_emails" edge to the SentEmail entity.
func (m *ProfileMutation) RemovedSentEmailsIDs() (ids []int) {
	for id := range m.removedsent_emails {
		ids = append(ids, id)
	}
	return
}

// SentEmailsIDs returns the "sent_emails" edge IDs in the mutation.
func (m *ProfileMutation) SentEmailsIDs() (ids []int) {
	for id := range m.sent_emails {
		ids = append(ids, id)
	}
	return
}

// ResetSentEmails resets all changes to the "sent_emails" edge.
func (m *ProfileMutation) ResetSentEmails() {
	m.sent_emails = nil
	m.clearedsent_emails = false
	m.removedsent_emails = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProfileMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProfileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProfileMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddSubscriptionIDs adds the "subscription" edge to the MonthlySubscription entity by ids.
func (m *ProfileMutation) AddSubscriptionIDs(ids ...int) {
	if m.subscription == nil {
		m.subscription = make(map[int]struct{})
	}
	for i := range ids {
		m.subscription[ids[i]] = struct{}{}
	}
}

// ClearSubscription clears the "subscription" edge to the MonthlySubscription entity.
func (m *ProfileMutation) ClearSubscription() {
	m.clearedsubscription = true
}

// SubscriptionCleared reports if the "subscription" edge to the MonthlySubscription entity was cleared.
func (m *ProfileMutation) SubscriptionCleared() bool {
	return m.clearedsubscription
}

// RemoveSubscriptionIDs removes the "subscription" edge to the MonthlySubscription entity by IDs.
func (m *ProfileMutation) RemoveSubscriptionIDs(ids ...int) {
	if m.removedsubscription == nil {
		m.removedsubscription = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscription, ids[i])
		m.removedsubscription[ids[i]] = struct{}{}
	}
}

// RemovedSubscription returns the removed IDs of the "subscription" edge to the MonthlySubscription entity.
func (m *ProfileMutation) RemovedSubscriptionIDs() (ids []int) {
	for id := range m.removedsubscription {
		ids = append(ids, id)
	}
	return
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
func (m *ProfileMutation) SubscriptionIDs() (ids []int) {
	for id := range m.subscription {
		ids = append(ids, id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *ProfileMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
	m.removedsubscription = nil
}

// Where appends a list predicates to the ProfileMutation builder.
func (m *ProfileMutation) Where(ps ...predicate.Profile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Profile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Profile).
func (m *ProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, profile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profile.FieldUpdatedAt)
	}
	if m.bio != nil {
		fields = append(fields, profile.FieldBio)
	}
	if m.birthdate != nil {
		fields = append(fields, profile.FieldBirthdate)
	}
	if m.age != nil {
		fields = append(fields, profile.FieldAge)
	}
	if m.fully_onboarded != nil {
		fields = append(fields, profile.FieldFullyOnboarded)
	}
	if m.phone_number_e164 != nil {
		fields = append(fields, profile.FieldPhoneNumberE164)
	}
	if m.country_code != nil {
		fields = append(fields, profile.FieldCountryCode)
	}
	if m.phone_verified != nil {
		fields = append(fields, profile.FieldPhoneVerified)
	}
	if m.stripe_id != nil {
		fields = append(fields, profile.FieldStripeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldCreatedAt:
		return m.CreatedAt()
	case profile.FieldUpdatedAt:
		return m.UpdatedAt()
	case profile.FieldBio:
		return m.Bio()
	case profile.FieldBirthdate:
		return m.Birthdate()
	case profile.FieldAge:
		return m.Age()
	case profile.FieldFullyOnboarded:
		return m.FullyOnboarded()
	case profile.FieldPhoneNumberE164:
		return m.PhoneNumberE164()
	case profile.FieldCountryCode:
		return m.CountryCode()
	case profile.FieldPhoneVerified:
		return m.PhoneVerified()
	case profile.FieldStripeID:
		return m.StripeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profile.FieldBio:
		return m.OldBio(ctx)
	case profile.FieldBirthdate:
		return m.OldBirthdate(ctx)
	case profile.FieldAge:
		return m.OldAge(ctx)
	case profile.FieldFullyOnboarded:
		return m.OldFullyOnboarded(ctx)
	case profile.FieldPhoneNumberE164:
		return m.OldPhoneNumberE164(ctx)
	case profile.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case profile.FieldPhoneVerified:
		return m.OldPhoneVerified(ctx)
	case profile.FieldStripeID:
		return m.OldStripeID(ctx)
	}
	return nil, fmt.Errorf("unknown Profile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profile.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case profile.FieldBirthdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdate(v)
		return nil
	case profile.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case profile.FieldFullyOnboarded:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullyOnboarded(v)
		return nil
	case profile.FieldPhoneNumberE164:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumberE164(v)
		return nil
	case profile.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case profile.FieldPhoneVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneVerified(v)
		return nil
	case profile.FieldStripeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeID(v)
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, profile.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case profile.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown Profile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(profile.FieldBio) {
		fields = append(fields, profile.FieldBio)
	}
	if m.FieldCleared(profile.FieldBirthdate) {
		fields = append(fields, profile.FieldBirthdate)
	}
	if m.FieldCleared(profile.FieldAge) {
		fields = append(fields, profile.FieldAge)
	}
	if m.FieldCleared(profile.FieldPhoneNumberE164) {
		fields = append(fields, profile.FieldPhoneNumberE164)
	}
	if m.FieldCleared(profile.FieldCountryCode) {
		fields = append(fields, profile.FieldCountryCode)
	}
	if m.FieldCleared(profile.FieldPhoneVerified) {
		fields = append(fields, profile.FieldPhoneVerified)
	}
	if m.FieldCleared(profile.FieldStripeID) {
		fields = append(fields, profile.FieldStripeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileMutation) ClearField(name string) error {
	switch name {
	case profile.FieldBio:
		m.ClearBio()
		return nil
	case profile.FieldBirthdate:
		m.ClearBirthdate()
		return nil
	case profile.FieldAge:
		m.ClearAge()
		return nil
	case profile.FieldPhoneNumberE164:
		m.ClearPhoneNumberE164()
		return nil
	case profile.FieldCountryCode:
		m.ClearCountryCode()
		return nil
	case profile.FieldPhoneVerified:
		m.ClearPhoneVerified()
		return nil
	case profile.FieldStripeID:
		m.ClearStripeID()
		return nil
	}
	return fmt.Errorf("unknown Profile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileMutation) ResetField(name string) error {
	switch name {
	case profile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profile.FieldBio:
		m.ResetBio()
		return nil
	case profile.FieldBirthdate:
		m.ResetBirthdate()
		return nil
	case profile.FieldAge:
		m.ResetAge()
		return nil
	case profile.FieldFullyOnboarded:
		m.ResetFullyOnboarded()
		return nil
	case profile.FieldPhoneNumberE164:
		m.ResetPhoneNumberE164()
		return nil
	case profile.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case profile.FieldPhoneVerified:
		m.ResetPhoneVerified()
		return nil
	case profile.FieldStripeID:
		m.ResetStripeID()
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.friends != nil {
		edges = append(edges, profile.EdgeFriends)
	}
	if m.photos != nil {
		edges = append(edges, profile.EdgePhotos)
	}
	if m.profile_image != nil {
		edges = append(edges, profile.EdgeProfileImage)
	}
	if m.notifications != nil {
		edges = append(edges, profile.EdgeNotifications)
	}
	if m.invitations != nil {
		edges = append(edges, profile.EdgeInvitations)
	}
	if m.fcm_push_subscriptions != nil {
		edges = append(edges, profile.EdgeFcmPushSubscriptions)
	}
	if m.pwa_push_subscriptions != nil {
		edges = append(edges, profile.EdgePwaPushSubscriptions)
	}
	if m.notification_permissions != nil {
		edges = append(edges, profile.EdgeNotificationPermissions)
	}
	if m.notification_times != nil {
		edges = append(edges, profile.EdgeNotificationTimes)
	}
	if m.phone_verification_code != nil {
		edges = append(edges, profile.EdgePhoneVerificationCode)
	}
	if m.sent_emails != nil {
		edges = append(edges, profile.EdgeSentEmails)
	}
	if m.user != nil {
		edges = append(edges, profile.EdgeUser)
	}
	if m.subscription != nil {
		edges = append(edges, profile.EdgeSubscription)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeFriends:
		ids := make([]ent.Value, 0, len(m.friends))
		for id := range m.friends {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgePhotos:
		ids := make([]ent.Value, 0, len(m.photos))
		for id := range m.photos {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeProfileImage:
		if id := m.profile_image; id != nil {
			return []ent.Value{*id}
		}
	case profile.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.invitations))
		for id := range m.invitations {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeFcmPushSubscriptions:
		ids := make([]ent.Value, 0, len(m.fcm_push_subscriptions))
		for id := range m.fcm_push_subscriptions {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgePwaPushSubscriptions:
		ids := make([]ent.Value, 0, len(m.pwa_push_subscriptions))
		for id := range m.pwa_push_subscriptions {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeNotificationPermissions:
		ids := make([]ent.Value, 0, len(m.notification_permissions))
		for id := range m.notification_permissions {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeNotificationTimes:
		ids := make([]ent.Value, 0, len(m.notification_times))
		for id := range m.notification_times {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgePhoneVerificationCode:
		ids := make([]ent.Value, 0, len(m.phone_verification_code))
		for id := range m.phone_verification_code {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeSentEmails:
		ids := make([]ent.Value, 0, len(m.sent_emails))
		for id := range m.sent_emails {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case profile.EdgeSubscription:
		ids := make([]ent.Value, 0, len(m.subscription))
		for id := range m.subscription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedfriends != nil {
		edges = append(edges, profile.EdgeFriends)
	}
	if m.removedphotos != nil {
		edges = append(edges, profile.EdgePhotos)
	}
	if m.removednotifications != nil {
		edges = append(edges, profile.EdgeNotifications)
	}
	if m.removedinvitations != nil {
		edges = append(edges, profile.EdgeInvitations)
	}
	if m.removedfcm_push_subscriptions != nil {
		edges = append(edges, profile.EdgeFcmPushSubscriptions)
	}
	if m.removedpwa_push_subscriptions != nil {
		edges = append(edges, profile.EdgePwaPushSubscriptions)
	}
	if m.removednotification_permissions != nil {
		edges = append(edges, profile.EdgeNotificationPermissions)
	}
	if m.removednotification_times != nil {
		edges = append(edges, profile.EdgeNotificationTimes)
	}
	if m.removedphone_verification_code != nil {
		edges = append(edges, profile.EdgePhoneVerificationCode)
	}
	if m.removedsent_emails != nil {
		edges = append(edges, profile.EdgeSentEmails)
	}
	if m.removedsubscription != nil {
		edges = append(edges, profile.EdgeSubscription)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeFriends:
		ids := make([]ent.Value, 0, len(m.removedfriends))
		for id := range m.removedfriends {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgePhotos:
		ids := make([]ent.Value, 0, len(m.removedphotos))
		for id := range m.removedphotos {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.removedinvitations))
		for id := range m.removedinvitations {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeFcmPushSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedfcm_push_subscriptions))
		for id := range m.removedfcm_push_subscriptions {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgePwaPushSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedpwa_push_subscriptions))
		for id := range m.removedpwa_push_subscriptions {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeNotificationPermissions:
		ids := make([]ent.Value, 0, len(m.removednotification_permissions))
		for id := range m.removednotification_permissions {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeNotificationTimes:
		ids := make([]ent.Value, 0, len(m.removednotification_times))
		for id := range m.removednotification_times {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgePhoneVerificationCode:
		ids := make([]ent.Value, 0, len(m.removedphone_verification_code))
		for id := range m.removedphone_verification_code {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeSentEmails:
		ids := make([]ent.Value, 0, len(m.removedsent_emails))
		for id := range m.removedsent_emails {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeSubscription:
		ids := make([]ent.Value, 0, len(m.removedsubscription))
		for id := range m.removedsubscription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedfriends {
		edges = append(edges, profile.EdgeFriends)
	}
	if m.clearedphotos {
		edges = append(edges, profile.EdgePhotos)
	}
	if m.clearedprofile_image {
		edges = append(edges, profile.EdgeProfileImage)
	}
	if m.clearednotifications {
		edges = append(edges, profile.EdgeNotifications)
	}
	if m.clearedinvitations {
		edges = append(edges, profile.EdgeInvitations)
	}
	if m.clearedfcm_push_subscriptions {
		edges = append(edges, profile.EdgeFcmPushSubscriptions)
	}
	if m.clearedpwa_push_subscriptions {
		edges = append(edges, profile.EdgePwaPushSubscriptions)
	}
	if m.clearednotification_permissions {
		edges = append(edges, profile.EdgeNotificationPermissions)
	}
	if m.clearednotification_times {
		edges = append(edges, profile.EdgeNotificationTimes)
	}
	if m.clearedphone_verification_code {
		edges = append(edges, profile.EdgePhoneVerificationCode)
	}
	if m.clearedsent_emails {
		edges = append(edges, profile.EdgeSentEmails)
	}
	if m.cleareduser {
		edges = append(edges, profile.EdgeUser)
	}
	if m.clearedsubscription {
		edges = append(edges, profile.EdgeSubscription)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case profile.EdgeFriends:
		return m.clearedfriends
	case profile.EdgePhotos:
		return m.clearedphotos
	case profile.EdgeProfileImage:
		return m.clearedprofile_image
	case profile.EdgeNotifications:
		return m.clearednotifications
	case profile.EdgeInvitations:
		return m.clearedinvitations
	case profile.EdgeFcmPushSubscriptions:
		return m.clearedfcm_push_subscriptions
	case profile.EdgePwaPushSubscriptions:
		return m.clearedpwa_push_subscriptions
	case profile.EdgeNotificationPermissions:
		return m.clearednotification_permissions
	case profile.EdgeNotificationTimes:
		return m.clearednotification_times
	case profile.EdgePhoneVerificationCode:
		return m.clearedphone_verification_code
	case profile.EdgeSentEmails:
		return m.clearedsent_emails
	case profile.EdgeUser:
		return m.cleareduser
	case profile.EdgeSubscription:
		return m.clearedsubscription
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileMutation) ClearEdge(name string) error {
	switch name {
	case profile.EdgeProfileImage:
		m.ClearProfileImage()
		return nil
	case profile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Profile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileMutation) ResetEdge(name string) error {
	switch name {
	case profile.EdgeFriends:
		m.ResetFriends()
		return nil
	case profile.EdgePhotos:
		m.ResetPhotos()
		return nil
	case profile.EdgeProfileImage:
		m.ResetProfileImage()
		return nil
	case profile.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case profile.EdgeInvitations:
		m.ResetInvitations()
		return nil
	case profile.EdgeFcmPushSubscriptions:
		m.ResetFcmPushSubscriptions()
		return nil
	case profile.EdgePwaPushSubscriptions:
		m.ResetPwaPushSubscriptions()
		return nil
	case profile.EdgeNotificationPermissions:
		m.ResetNotificationPermissions()
		return nil
	case profile.EdgeNotificationTimes:
		m.ResetNotificationTimes()
		return nil
	case profile.EdgePhoneVerificationCode:
		m.ResetPhoneVerificationCode()
		return nil
	case profile.EdgeSentEmails:
		m.ResetSentEmails()
		return nil
	case profile.EdgeUser:
		m.ResetUser()
		return nil
	case profile.EdgeSubscription:
		m.ResetSubscription()
		return nil
	}
	return fmt.Errorf("unknown Profile edge %s", name)
}

// PwaPushSubscriptionMutation represents an operation that mutates the PwaPushSubscription nodes in the graph.
type PwaPushSubscriptionMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	endpoint       *string
	p256dh         *string
	auth           *string
	clearedFields  map[string]struct{}
	profile        *int
	clearedprofile bool
	done           bool
	oldValue       func(context.Context) (*PwaPushSubscription, error)
	predicates     []predicate.PwaPushSubscription
}

var _ ent.Mutation = (*PwaPushSubscriptionMutation)(nil)

// pwapushsubscriptionOption allows management of the mutation configuration using functional options.
type pwapushsubscriptionOption func(*PwaPushSubscriptionMutation)

// newPwaPushSubscriptionMutation creates new mutation for the PwaPushSubscription entity.
func newPwaPushSubscriptionMutation(c config, op Op, opts ...pwapushsubscriptionOption) *PwaPushSubscriptionMutation {
	m := &PwaPushSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypePwaPushSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPwaPushSubscriptionID sets the ID field of the mutation.
func withPwaPushSubscriptionID(id int) pwapushsubscriptionOption {
	return func(m *PwaPushSubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *PwaPushSubscription
		)
		m.oldValue = func(ctx context.Context) (*PwaPushSubscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PwaPushSubscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPwaPushSubscription sets the old PwaPushSubscription of the mutation.
func withPwaPushSubscription(node *PwaPushSubscription) pwapushsubscriptionOption {
	return func(m *PwaPushSubscriptionMutation) {
		m.oldValue = func(context.Context) (*PwaPushSubscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PwaPushSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PwaPushSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PwaPushSubscriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PwaPushSubscriptionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PwaPushSubscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PwaPushSubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PwaPushSubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PwaPushSubscription entity.
// If the PwaPushSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PwaPushSubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PwaPushSubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PwaPushSubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PwaPushSubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PwaPushSubscription entity.
// If the PwaPushSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PwaPushSubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PwaPushSubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEndpoint sets the "endpoint" field.
func (m *PwaPushSubscriptionMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *PwaPushSubscriptionMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the PwaPushSubscription entity.
// If the PwaPushSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PwaPushSubscriptionMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *PwaPushSubscriptionMutation) ResetEndpoint() {
	m.endpoint = nil
}

// SetP256dh sets the "p256dh" field.
func (m *PwaPushSubscriptionMutation) SetP256dh(s string) {
	m.p256dh = &s
}

// P256dh returns the value of the "p256dh" field in the mutation.
func (m *PwaPushSubscriptionMutation) P256dh() (r string, exists bool) {
	v := m.p256dh
	if v == nil {
		return
	}
	return *v, true
}

// OldP256dh returns the old "p256dh" field's value of the PwaPushSubscription entity.
// If the PwaPushSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PwaPushSubscriptionMutation) OldP256dh(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldP256dh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldP256dh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldP256dh: %w", err)
	}
	return oldValue.P256dh, nil
}

// ResetP256dh resets all changes to the "p256dh" field.
func (m *PwaPushSubscriptionMutation) ResetP256dh() {
	m.p256dh = nil
}

// SetAuth sets the "auth" field.
func (m *PwaPushSubscriptionMutation) SetAuth(s string) {
	m.auth = &s
}

// Auth returns the value of the "auth" field in the mutation.
func (m *PwaPushSubscriptionMutation) Auth() (r string, exists bool) {
	v := m.auth
	if v == nil {
		return
	}
	return *v, true
}

// OldAuth returns the old "auth" field's value of the PwaPushSubscription entity.
// If the PwaPushSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PwaPushSubscriptionMutation) OldAuth(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuth: %w", err)
	}
	return oldValue.Auth, nil
}

// ResetAuth resets all changes to the "auth" field.
func (m *PwaPushSubscriptionMutation) ResetAuth() {
	m.auth = nil
}

// SetProfileID sets the "profile_id" field.
func (m *PwaPushSubscriptionMutation) SetProfileID(i int) {
	m.profile = &i
}

// ProfileID returns the value of the "profile_id" field in the mutation.
func (m *PwaPushSubscriptionMutation) ProfileID() (r int, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileID returns the old "profile_id" field's value of the PwaPushSubscription entity.
// If the PwaPushSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PwaPushSubscriptionMutation) OldProfileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileID: %w", err)
	}
	return oldValue.ProfileID, nil
}

// ResetProfileID resets all changes to the "profile_id" field.
func (m *PwaPushSubscriptionMutation) ResetProfileID() {
	m.profile = nil
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *PwaPushSubscriptionMutation) ClearProfile() {
	m.clearedprofile = true
	m.clearedFields[pwapushsubscription.FieldProfileID] = struct{}{}
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *PwaPushSubscriptionMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *PwaPushSubscriptionMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *PwaPushSubscriptionMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the PwaPushSubscriptionMutation builder.
func (m *PwaPushSubscriptionMutation) Where(ps ...predicate.PwaPushSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PwaPushSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PwaPushSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PwaPushSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PwaPushSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PwaPushSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PwaPushSubscription).
func (m *PwaPushSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PwaPushSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, pwapushsubscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pwapushsubscription.FieldUpdatedAt)
	}
	if m.endpoint != nil {
		fields = append(fields, pwapushsubscription.FieldEndpoint)
	}
	if m.p256dh != nil {
		fields = append(fields, pwapushsubscription.FieldP256dh)
	}
	if m.auth != nil {
		fields = append(fields, pwapushsubscription.FieldAuth)
	}
	if m.profile != nil {
		fields = append(fields, pwapushsubscription.FieldProfileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PwaPushSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pwapushsubscription.FieldCreatedAt:
		return m.CreatedAt()
	case pwapushsubscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case pwapushsubscription.FieldEndpoint:
		return m.Endpoint()
	case pwapushsubscription.FieldP256dh:
		return m.P256dh()
	case pwapushsubscription.FieldAuth:
		return m.Auth()
	case pwapushsubscription.FieldProfileID:
		return m.ProfileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PwaPushSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pwapushsubscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pwapushsubscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pwapushsubscription.FieldEndpoint:
		return m.OldEndpoint(ctx)
	case pwapushsubscription.FieldP256dh:
		return m.OldP256dh(ctx)
	case pwapushsubscription.FieldAuth:
		return m.OldAuth(ctx)
	case pwapushsubscription.FieldProfileID:
		return m.OldProfileID(ctx)
	}
	return nil, fmt.Errorf("unknown PwaPushSubscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PwaPushSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pwapushsubscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pwapushsubscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pwapushsubscription.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	case pwapushsubscription.FieldP256dh:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetP256dh(v)
		return nil
	case pwapushsubscription.FieldAuth:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuth(v)
		return nil
	case pwapushsubscription.FieldProfileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileID(v)
		return nil
	}
	return fmt.Errorf("unknown PwaPushSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PwaPushSubscriptionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PwaPushSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PwaPushSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PwaPushSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PwaPushSubscriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PwaPushSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PwaPushSubscriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PwaPushSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PwaPushSubscriptionMutation) ResetField(name string) error {
	switch name {
	case pwapushsubscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pwapushsubscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pwapushsubscription.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	case pwapushsubscription.FieldP256dh:
		m.ResetP256dh()
		return nil
	case pwapushsubscription.FieldAuth:
		m.ResetAuth()
		return nil
	case pwapushsubscription.FieldProfileID:
		m.ResetProfileID()
		return nil
	}
	return fmt.Errorf("unknown PwaPushSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PwaPushSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.profile != nil {
		edges = append(edges, pwapushsubscription.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PwaPushSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pwapushsubscription.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PwaPushSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PwaPushSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PwaPushSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprofile {
		edges = append(edges, pwapushsubscription.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PwaPushSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case pwapushsubscription.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PwaPushSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case pwapushsubscription.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown PwaPushSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PwaPushSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case pwapushsubscription.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown PwaPushSubscription edge %s", name)
}

// SentEmailMutation represents an operation that mutates the SentEmail nodes in the graph.
type SentEmailMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	_type          *sentemail.Type
	clearedFields  map[string]struct{}
	profile        *int
	clearedprofile bool
	done           bool
	oldValue       func(context.Context) (*SentEmail, error)
	predicates     []predicate.SentEmail
}

var _ ent.Mutation = (*SentEmailMutation)(nil)

// sentemailOption allows management of the mutation configuration using functional options.
type sentemailOption func(*SentEmailMutation)

// newSentEmailMutation creates new mutation for the SentEmail entity.
func newSentEmailMutation(c config, op Op, opts ...sentemailOption) *SentEmailMutation {
	m := &SentEmailMutation{
		config:        c,
		op:            op,
		typ:           TypeSentEmail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSentEmailID sets the ID field of the mutation.
func withSentEmailID(id int) sentemailOption {
	return func(m *SentEmailMutation) {
		var (
			err   error
			once  sync.Once
			value *SentEmail
		)
		m.oldValue = func(ctx context.Context) (*SentEmail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SentEmail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSentEmail sets the old SentEmail of the mutation.
func withSentEmail(node *SentEmail) sentemailOption {
	return func(m *SentEmailMutation) {
		m.oldValue = func(context.Context) (*SentEmail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SentEmailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SentEmailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SentEmailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SentEmailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SentEmail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SentEmailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SentEmailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SentEmail entity.
// If the SentEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentEmailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SentEmailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SentEmailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SentEmailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SentEmail entity.
// If the SentEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentEmailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SentEmailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *SentEmailMutation) SetType(s sentemail.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SentEmailMutation) GetType() (r sentemail.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SentEmail entity.
// If the SentEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentEmailMutation) OldType(ctx context.Context) (v sentemail.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SentEmailMutation) ResetType() {
	m._type = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *SentEmailMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *SentEmailMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *SentEmailMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *SentEmailMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *SentEmailMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *SentEmailMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the SentEmailMutation builder.
func (m *SentEmailMutation) Where(ps ...predicate.SentEmail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SentEmailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SentEmailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SentEmail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SentEmailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SentEmailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SentEmail).
func (m *SentEmailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SentEmailMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, sentemail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sentemail.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, sentemail.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SentEmailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sentemail.FieldCreatedAt:
		return m.CreatedAt()
	case sentemail.FieldUpdatedAt:
		return m.UpdatedAt()
	case sentemail.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SentEmailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sentemail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sentemail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sentemail.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown SentEmail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SentEmailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sentemail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sentemail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sentemail.FieldType:
		v, ok := value.(sentemail.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown SentEmail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SentEmailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SentEmailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SentEmailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SentEmail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SentEmailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SentEmailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SentEmailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SentEmail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SentEmailMutation) ResetField(name string) error {
	switch name {
	case sentemail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sentemail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sentemail.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown SentEmail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SentEmailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.profile != nil {
		edges = append(edges, sentemail.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SentEmailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sentemail.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SentEmailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SentEmailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SentEmailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprofile {
		edges = append(edges, sentemail.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SentEmailMutation) EdgeCleared(name string) bool {
	switch name {
	case sentemail.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SentEmailMutation) ClearEdge(name string) error {
	switch name {
	case sentemail.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown SentEmail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SentEmailMutation) ResetEdge(name string) error {
	switch name {
	case sentemail.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown SentEmail edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	email               *string
	password            *string
	verified            *bool
	last_online         *time.Time
	clearedFields       map[string]struct{}
	owner               map[int]struct{}
	removedowner        map[int]struct{}
	clearedowner        bool
	profile             *int
	clearedprofile      bool
	last_seen_at        map[int]struct{}
	removedlast_seen_at map[int]struct{}
	clearedlast_seen_at bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetVerified sets the "verified" field.
func (m *UserMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *UserMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *UserMutation) ResetVerified() {
	m.verified = nil
}

// SetLastOnline sets the "last_online" field.
func (m *UserMutation) SetLastOnline(t time.Time) {
	m.last_online = &t
}

// LastOnline returns the value of the "last_online" field in the mutation.
func (m *UserMutation) LastOnline() (r time.Time, exists bool) {
	v := m.last_online
	if v == nil {
		return
	}
	return *v, true
}

// OldLastOnline returns the old "last_online" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastOnline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastOnline: %w", err)
	}
	return oldValue.LastOnline, nil
}

// ClearLastOnline clears the value of the "last_online" field.
func (m *UserMutation) ClearLastOnline() {
	m.last_online = nil
	m.clearedFields[user.FieldLastOnline] = struct{}{}
}

// LastOnlineCleared returns if the "last_online" field was cleared in this mutation.
func (m *UserMutation) LastOnlineCleared() bool {
	_, ok := m.clearedFields[user.FieldLastOnline]
	return ok
}

// ResetLastOnline resets all changes to the "last_online" field.
func (m *UserMutation) ResetLastOnline() {
	m.last_online = nil
	delete(m.clearedFields, user.FieldLastOnline)
}

// AddOwnerIDs adds the "owner" edge to the PasswordToken entity by ids.
func (m *UserMutation) AddOwnerIDs(ids ...int) {
	if m.owner == nil {
		m.owner = make(map[int]struct{})
	}
	for i := range ids {
		m.owner[ids[i]] = struct{}{}
	}
}

// ClearOwner clears the "owner" edge to the PasswordToken entity.
func (m *UserMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the PasswordToken entity was cleared.
func (m *UserMutation) OwnerCleared() bool {
	return m.clearedowner
}

// RemoveOwnerIDs removes the "owner" edge to the PasswordToken entity by IDs.
func (m *UserMutation) RemoveOwnerIDs(ids ...int) {
	if m.removedowner == nil {
		m.removedowner = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owner, ids[i])
		m.removedowner[ids[i]] = struct{}{}
	}
}

// RemovedOwner returns the removed IDs of the "owner" edge to the PasswordToken entity.
func (m *UserMutation) RemovedOwnerIDs() (ids []int) {
	for id := range m.removedowner {
		ids = append(ids, id)
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
func (m *UserMutation) OwnerIDs() (ids []int) {
	for id := range m.owner {
		ids = append(ids, id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *UserMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
	m.removedowner = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *UserMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *UserMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *UserMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *UserMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// AddLastSeenAtIDs adds the "last_seen_at" edge to the LastSeenOnline entity by ids.
func (m *UserMutation) AddLastSeenAtIDs(ids ...int) {
	if m.last_seen_at == nil {
		m.last_seen_at = make(map[int]struct{})
	}
	for i := range ids {
		m.last_seen_at[ids[i]] = struct{}{}
	}
}

// ClearLastSeenAt clears the "last_seen_at" edge to the LastSeenOnline entity.
func (m *UserMutation) ClearLastSeenAt() {
	m.clearedlast_seen_at = true
}

// LastSeenAtCleared reports if the "last_seen_at" edge to the LastSeenOnline entity was cleared.
func (m *UserMutation) LastSeenAtCleared() bool {
	return m.clearedlast_seen_at
}

// RemoveLastSeenAtIDs removes the "last_seen_at" edge to the LastSeenOnline entity by IDs.
func (m *UserMutation) RemoveLastSeenAtIDs(ids ...int) {
	if m.removedlast_seen_at == nil {
		m.removedlast_seen_at = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.last_seen_at, ids[i])
		m.removedlast_seen_at[ids[i]] = struct{}{}
	}
}

// RemovedLastSeenAt returns the removed IDs of the "last_seen_at" edge to the LastSeenOnline entity.
func (m *UserMutation) RemovedLastSeenAtIDs() (ids []int) {
	for id := range m.removedlast_seen_at {
		ids = append(ids, id)
	}
	return
}

// LastSeenAtIDs returns the "last_seen_at" edge IDs in the mutation.
func (m *UserMutation) LastSeenAtIDs() (ids []int) {
	for id := range m.last_seen_at {
		ids = append(ids, id)
	}
	return
}

// ResetLastSeenAt resets all changes to the "last_seen_at" edge.
func (m *UserMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
	m.clearedlast_seen_at = false
	m.removedlast_seen_at = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.verified != nil {
		fields = append(fields, user.FieldVerified)
	}
	if m.last_online != nil {
		fields = append(fields, user.FieldLastOnline)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldVerified:
		return m.Verified()
	case user.FieldLastOnline:
		return m.LastOnline()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldVerified:
		return m.OldVerified(ctx)
	case user.FieldLastOnline:
		return m.OldLastOnline(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case user.FieldLastOnline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastOnline(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldLastOnline) {
		fields = append(fields, user.FieldLastOnline)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldLastOnline:
		m.ClearLastOnline()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldVerified:
		m.ResetVerified()
		return nil
	case user.FieldLastOnline:
		m.ResetLastOnline()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, user.EdgeOwner)
	}
	if m.profile != nil {
		edges = append(edges, user.EdgeProfile)
	}
	if m.last_seen_at != nil {
		edges = append(edges, user.EdgeLastSeenAt)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOwner:
		ids := make([]ent.Value, 0, len(m.owner))
		for id := range m.owner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeLastSeenAt:
		ids := make([]ent.Value, 0, len(m.last_seen_at))
		for id := range m.last_seen_at {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedowner != nil {
		edges = append(edges, user.EdgeOwner)
	}
	if m.removedlast_seen_at != nil {
		edges = append(edges, user.EdgeLastSeenAt)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOwner:
		ids := make([]ent.Value, 0, len(m.removedowner))
		for id := range m.removedowner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLastSeenAt:
		ids := make([]ent.Value, 0, len(m.removedlast_seen_at))
		for id := range m.removedlast_seen_at {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, user.EdgeOwner)
	}
	if m.clearedprofile {
		edges = append(edges, user.EdgeProfile)
	}
	if m.clearedlast_seen_at {
		edges = append(edges, user.EdgeLastSeenAt)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeOwner:
		return m.clearedowner
	case user.EdgeProfile:
		return m.clearedprofile
	case user.EdgeLastSeenAt:
		return m.clearedlast_seen_at
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeOwner:
		m.ResetOwner()
		return nil
	case user.EdgeProfile:
		m.ResetProfile()
		return nil
	case user.EdgeLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
